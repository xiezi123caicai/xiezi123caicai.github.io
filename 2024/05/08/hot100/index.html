<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="hot100, Hexu&#39;s learn blog">
    <meta name="description" content="study">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>hot100 | Hexu&#39;s learn blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexu&#39;s learn blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexu&#39;s learn blog</div>
        <div class="logo-desc">
            
            study
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/xiezi123caicai" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/xiezi123caicai" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">hot100</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/leecode%E9%A2%98/">
                                <span class="chip bg-color">leecode题</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" class="post-category">
                                编程学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-08
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    20.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    73 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="1-两数之和✅"><a href="#1-两数之和✅" class="headerlink" title="1. 两数之和✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>✅</h4><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<p><strong>解析：</strong>用哈希表辅助判断。对于一个元素 <code>nums[i]</code>，你想知道有没有另一个元素 <code>nums[j]</code> 的值为 <code>target - nums[i]</code>，这很简单，我们用一个哈希表记录每个元素的值到索引的映射，这样就能快速判断数组中是否有一个值为 <code>target - nums[i]</code> 的元素了。</p>
<p>简单说，<strong>数组其实可以理解为一个「索引 -&gt; 值」的哈希表映射，而我们又建立一个「值 -&gt; 索引」的映射即可完成此题</strong>。</p>
<p><img src="/2024/05/08/hot100/1715147141098-1.png"></p>
<h4 id="49-字母异位词分组✅"><a href="#49-字母异位词分组✅" class="headerlink" title="49. 字母异位词分组✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a>✅</h4><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。<strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>解析：</strong>异位词这类问题的关键在于，你如何迅速判断两个字符串是异位词，主要考察数据编码和哈希表的使用：更好的编码方案是利用每个字符的出现次数进行编码，也就是下面的解法代码。</p>
<p><img src="/2024/05/08/hot100/1715147251901-4.png"></p>
<h4 id="128-最长连续序列✅"><a href="#128-最长连续序列✅" class="headerlink" title="128. 最长连续序列✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a>✅</h4><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>解析：</strong>可以用空间换时间的思路，把数组元素放到哈希集合里面，然后去寻找连续序列的第一个元素，即可在 <code>O(N)</code> 时间找到答案。</p>
<p>比方说 <code>nums = [8,4,9,1,3,2]</code>，我们先找到 1，然后递增，找到了 2, 3, 4，这就是一个长度为 4 的序列。又找到 8，网上递增执照到了 9，这是一个长度为 2 的序列。虽然 for 循环嵌套 while 循环，但是每个元素只会被遍历到最多两次，所以均摊时间复杂度依然为 <code>O(N)</code></p>
<p><img src="/2024/05/08/hot100/1715147541313-1.png"></p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="283-移动零✅"><a href="#283-移动零✅" class="headerlink" title="283. 移动零✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a>✅</h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>解析：可以直接复用</strong> <strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element">27. 移除元素</a></strong> <strong>的解法，先移除所有 0，然后把最后的元素都置为 0，就相当于移动 0 的效果。</strong></p>
<p><img src="/2024/05/08/hot100/1715147984443-1.png"></p>
<h4 id="11-盛最多水的容器💪"><a href="#11-盛最多水的容器💪" class="headerlink" title="11. 盛最多水的容器💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a>💪</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p>
<p><strong>解析：用</strong> <strong><code>left</code></strong> <strong>和</strong> <strong><code>right</code></strong> <strong>两个指针从两端向中心收缩，一边收缩一边计算</strong> <strong><code>[left, right]</code></strong> <strong>之间的矩形面积，取最大的面积值即是答案。</strong></p>
<p><strong>矩形的高度是由</strong> <strong><code>min(height[left], height[right])</code></strong> <strong>即较低的一边决定的</strong>：你如果移动较低的那一边，那条边可能会变高，使得矩形的高度变大，进而就「有可能」使得矩形的面积变大；相反，如果你去移动较高的那一边，矩形的高度是无论如何都不会变大的，所以不可能使矩形的面积变得更大。</p>
<p><img src="/2024/05/08/hot100/1715148028619-4.png"></p>
<h4 id="15-三数之和💪"><a href="#15-三数之和💪" class="headerlink" title="15. 三数之和💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>💪</h4><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。<strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>解析：</strong>nSum 系列问题的核心思路就是<strong>排序 +</strong> <strong>双指针</strong>。先给数组从小到大排序，然后双指针 <code>lo</code> 和 <code>hi</code> 分别在数组开头和结尾，这样就可以控制 <code>nums[lo]</code> 和 <code>nums[hi]</code> 这两数之和的大小：如果你想让它俩的和大一些，就让 <code>lo++</code>，如果你想让它俩的和小一些，就让 <code>hi--</code>。</p>
<p><img src="/2024/05/08/hot100/1715148627275-7.png"></p>
<h4 id="42-接雨水😤"><a href="#42-接雨水😤" class="headerlink" title="42. 接雨水😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>😤</h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/2024/05/08/hot100/1715148698583-10.png"></p>
<p><strong>解析：</strong>对于任意一个位置 <code>i</code>，能够装的水为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">water[i] = min(</span><br><span class="line">           # 左边最高的柱子</span><br><span class="line">           max(height[0..i]),</span><br><span class="line">           # 右边最高的柱子</span><br><span class="line">           max(height[i..end])</span><br><span class="line">        ) - height[i]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>关键在于，如何能够快速计算出某一个位置左侧所有柱子的最大高度和右侧所有柱子的最大高度</strong>。</p>
<p><img src="/2024/05/08/hot100/1715148766765-13.png"></p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="3-无重复字符的最长子串💪"><a href="#3-无重复字符的最长子串💪" class="headerlink" title="3. 无重复字符的最长子串💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>💪</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>解析：</strong>这题比其他滑动窗口的题目简单，连 <code>need</code> 和 <code>valid</code> 都不需要，而且更新窗口内数据也只需要简单的更新计数器 <code>window</code> 即可。当 <code>window[c]</code> 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 <code>left</code> 缩小窗口了。另外，要在收缩窗口完成后更新 <code>res</code>，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复。</p>
<p><img src="/2024/05/08/hot100/1715148804034-16.png"></p>
<h4 id="438-找到字符串中所有字母异位词-💀"><a href="#438-找到字符串中所有字母异位词-💀" class="headerlink" title="438. 找到字符串中所有字母异位词 💀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 💀</h4><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>解析：这题和</strong> <strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string">567. 字符串的排列</a></strong> <strong>一样，只不过找到一个合法异位词（排列）之后将它的起始索引加入结果列表即可。</strong></p>
<p><img src="/2024/05/08/hot100/1715149070227-19.png"></p>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="560-和为-K-的子数组😤"><a href="#560-和为-K-的子数组😤" class="headerlink" title="560. 和为 K 的子数组😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a>😤</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为</em> <em><code>k</code></em> <em>的子数组的个数</em> 。子数组是数组中元素的连续非空序列。</p>
<p><strong>解析：前缀和 +</strong> <strong>哈希表****优化</strong></p>
<p>定义 <code>pre[i]</code> 为 <code>[0..i]</code> 里所有数的和，则 <code>pre[i]</code> 可以由 <code>pre[i−1]</code> 递推而来，即：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[i]=pre[i−1]+nums[i]</span><br></pre></td></tr></tbody></table></figure>

<p>那么「<code>[j..i]</code> 这个子数组和为 <code>k</code> 」这个条件我们可以转化为<code>pre[i]−pre[j−1]==k</code></p>
<p>简单移项可得符合条件的下标 <code>j</code> 需要满足<code>pre[j−1]==pre[i]−k</code></p>
<p>所以我们考虑以 <code>i</code> 结尾的和为 <code>k</code> 的连续子数组个数时只要统计有多少个前缀和为 <code>pre[i]−k</code> 的 <code>pre[j]</code> 即可。我们建立哈希表，以和为键，出现次数为对应的值，记录 <code>pre[i]</code> 出现的次数，从左往右边更新哈希表边计算答案，那么以 <code>i</code> 结尾的答案 <code>mp[pre[i]−k]</code> 即可在 <code>O(1)</code> 时间内得到。最后的答案即为所有下标结尾的和为 <code>k</code> 的子数组个数之和。</p>
<p><img src="/2024/05/08/hot100/1715149121263-22.png"></p>
<h4 id="239-滑动窗口最大值💪"><a href="#239-滑动窗口最大值💪" class="headerlink" title="239. 滑动窗口最大值💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a>💪</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>解析：</strong>使用一个队列充当不断滑动的窗口，每次滑动记录其中的最大值：如何在 <code>O(1)</code> 时间计算最大值，只需要一个特殊的数据结构「单调队列」，<code>push</code> 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉，直到遇到更大的元素才停止删除。使用单调队列数据结构就能完成本题。</p>
<p><img src="/2024/05/08/hot100/1715149271434-25.png"></p>
<p><img src="/2024/05/08/hot100/1715149271434-26.png"></p>
<h4 id="76-最小覆盖子串😡"><a href="#76-最小覆盖子串😡" class="headerlink" title="76. 最小覆盖子串😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>😡</h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p>
<p><img src="/2024/05/08/hot100/1715149326681-31.png"></p>
<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h4 id="53-最大子数组和✅"><a href="#53-最大子数组和✅" class="headerlink" title="53. 最大子数组和✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a>✅</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>解析：</strong>这题类似 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence">最长递增子序列</a>，<code>dp</code> 数组的含义：<strong>以</strong> <strong><code>nums[i]</code></strong> <strong>为结尾的「最大子数组和」为</strong> **<code>dp[i]</code>**。<code>dp[i]</code> 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。在这两种选择中择优，就可以计算出最大子数组，而且空间复杂度还有优化空间</p>
<p><img src="/2024/05/08/hot100/1715149376479-34.png"></p>
<h4 id="56-合并区间💪"><a href="#56-合并区间💪" class="headerlink" title="56. 合并区间💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a>💪</h4><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start(i), end(i)]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>解析：</strong>一个区间可以表示为 <code>[start, end]</code>，先按区间的 <code>start</code> 排序：<strong>显然，对于几个相交区间合并后的结果区间</strong> <strong><code>x</code><strong>，</strong><code>x.start</code></strong> <strong>一定是这些相交区间中</strong> <strong><code>start</code></strong> **最小的，<code>x.end</code>一定是这些相交区间中 **<code>end</code> <strong>最大的</strong>：由于已经排了序，<code>x.start</code> 很好确定，求 <code>x.end</code> 也很容易，可以类比在数组中找最大值的过程。</p>
<p><img src="/2024/05/08/hot100/1715149526133-37.png"></p>
<h4 id="189-轮转数组😤"><a href="#189-轮转数组😤" class="headerlink" title="189. 轮转数组😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a>😤</h4><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>解析：</strong>当我们将数组的元素向右移动 <code>k</code> 次后，尾部 <code>k  mod  n</code> 个元素会移动至数组头部，其余元素向后移动 <code>k mod n</code> 个位置。</p>
<p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 <code>k  mod  n</code> 个元素就被移至数组头部，然后我们再翻转 <code>[0, k  mod  n − 1]</code> 区间的元素和 <code>[k  mod  n, n − 1]</code> 区间的元素即能得到最后的答案。</p>
<p><img src="/2024/05/08/hot100/1715149631790-40.png"></p>
<p><img src="/2024/05/08/hot100/1715149637446-43.png"></p>
<h4 id="238-除自身以外数组的乘积😤"><a href="#238-除自身以外数组的乘积😤" class="headerlink" title="238. 除自身以外数组的乘积😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a>😤</h4><p>给你一个整数数组 <code>nums</code>，返回 <em>数组</em> <em><code>answer</code></em> <em>，其中</em> <em><code>answer[i]</code></em> <em>等于</em> <em><code>nums</code></em> <em>中除</em> <em><code>nums[i]</code></em> <em>之外其余各元素的乘积</em> 。题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内。请 <strong>不要使用除法，</strong>且在 <code>O(</code><em><code>n</code></em><code>)</code> 时间复杂度内完成此题。</p>
<p><strong>解析：</strong></p>
<ol>
<li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li>
<li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li>
<li>这种方法的唯一变化就是我们没有构造 <code>R</code> 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 <code>answer[i]=answer[i]∗R</code> 。然后 <code>R</code> 更新为 <code>R=R∗nums[i]</code> ，其中变量 <code>R</code> 表示的就是索引右侧数字的乘积。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715149737656-46.png"></p>
<h4 id="41-缺失的第一个正数💀"><a href="#41-缺失的第一个正数💀" class="headerlink" title="41. 缺失的第一个正数💀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a>💀</h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p><strong>解析：</strong></p>
<ol>
<li>我们将数组中所有小于等于 <code>0</code> 的数修改为 <code>N+1</code> ；</li>
<li>我们遍历数组中的每一个数 <code>x</code>，它可能已经被打了标记，因此原本对应的数为 <code>∣x∣</code>，其中 <code>∣ ∣</code> 为绝对值符号。如果 <code>∣x∣∈[1,N]</code>，那么我们给数组中的第 <code>∣x∣−1</code> 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；</li>
<li>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 <code>N+1</code>，否则答案是第一个正数的位置加 <code>1</code>。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715149834995-53.png"></p>
<p><img src="/2024/05/08/hot100/1715149834996-54.png"></p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="73-矩阵置零✅"><a href="#73-矩阵置零✅" class="headerlink" title="73. 矩阵置零✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a>✅</h4><p>给定一个 <em><code>m</code></em><code>x</code><em><code>n</code></em> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p>
<p><strong>解析：</strong>我们可以用两个标记数组分别记录每一行和每一列是否有零出现。具体地，我们首先遍历该数组一次，如果某个元素为 <code>0</code>，那么就将该元素所在的行和列所对应标记数组的位置置为 <code>true</code>。最后我们再次遍历该数组，用标记数组更新原数组即可。</p>
<p><img src="/2024/05/08/hot100/1715149875575-59.png"></p>
<h4 id="54-螺旋矩阵💪"><a href="#54-螺旋矩阵💪" class="headerlink" title="54. 螺旋矩阵💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a>💪</h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><img src="/2024/05/08/hot100/1715149900858-62.png"></p>
<h4 id="48-旋转图像✅"><a href="#48-旋转图像✅" class="headerlink" title="48. 旋转图像✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a>✅</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>解析：先把二维矩阵沿对角线反转，然后反转矩阵的每一行，结果就是顺时针反转整个矩阵。</strong></p>
<p><img src="/2024/05/08/hot100/1715149951044-65.png"></p>
<h4 id="240-搜索二维矩阵-II✅"><a href="#240-搜索二维矩阵-II✅" class="headerlink" title="240. 搜索二维矩阵 II✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a>✅</h4><p>编写一个高效的算法来搜索 <em><code>m</code></em><code>x</code><em><code>n</code></em> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>解析：如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和</strong> <strong><code>target</code></strong> <strong>的相对大小来判断应该往哪移动，不断接近从而找到</strong> <strong><code>target</code></strong> <strong>的位置。</strong></p>
<p><img src="/2024/05/08/hot100/1715149978892-68.png"></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="160-相交链表✅"><a href="#160-相交链表✅" class="headerlink" title="160. 相交链表✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a>✅</h4><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p><strong>解析：</strong>这题难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应。</p>
<p>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>。</p>
<p><img src="/2024/05/08/hot100/1715150312132-71.png"></p>
<h4 id="206-反转链表💪"><a href="#206-反转链表💪" class="headerlink" title="206. 反转链表💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a>💪</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>解析：</strong>首先定义一个<code>cur</code>指针，指向头结点，再定义一个<code>pre</code>指针，初始化为<code>null</code>。然后就要开始反转了，首先要把 <code>cur-&gt;next</code> 节点用<code>tmp</code>指针保存一下，也就是保存一下这个节点。为什么要保存一下这个节点呢，因为接下来要改变 <code>cur-&gt;next</code> 的指向了，将<code>cur-&gt;next</code> 指向<code>pre</code> ，此时已经反转了第一个节点了。接下来，就是循环走如下代码逻辑了，继续移动<code>pre</code>和<code>cur</code>指针。最后，<code>cur</code> 指针已经指向了<code>null</code>，循环结束，链表也反转完毕了。 此时我们<code>return pre</code>指针就可以了，<code>pre</code>指针就指向了新的头结点。</p>
<p><img src="/2024/05/08/hot100/1715150350591-74.png"></p>
<h4 id="234-回文链表✅"><a href="#234-回文链表✅" class="headerlink" title="234. 回文链表✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a>✅</h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>解析：</strong></p>
<ol>
<li>先通过 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧</a> 中的快慢指针来找到链表的中点：</li>
<li>如果 <code>fast</code> 指针没有指向 <code>null</code>，说明链表长度为奇数，<code>slow</code> 还要再前进一步。</li>
<li>从 <code>slow</code> 开始反转后面的链表，现在就可以开始比较回文串了。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715150414911-77.png"></p>
<p>reverse方法看206翻转链表。</p>
<h4 id="141-环形链表✅"><a href="#141-环形链表✅" class="headerlink" title="141. 环形链表✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a>✅</h4><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code>不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><strong>解析：</strong>使用双指针技巧中的快慢指针，每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。</p>
<p><img src="/2024/05/08/hot100/1715150513842-80.png"></p>
<h4 id="142-环形链表-II✅"><a href="#142-环形链表-II✅" class="headerlink" title="142. 环形链表 II✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a>✅</h4><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回</em> <code>null</code>。如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>解析：</strong>假设快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点：</p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p>
<p><img src="/2024/05/08/hot100/1715150562710-83.png"></p>
<h4 id="21-合并两个有序链表💪"><a href="#21-合并两个有序链表💪" class="headerlink" title="21. 合并两个有序链表💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>💪</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>解析：</strong>算法的逻辑类似于「拉拉链」，<code>l1, l2</code> 类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并。<strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是</strong> <strong><code>dummy</code></strong> <strong>节点</strong>，它相当于是个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<p><img src="/2024/05/08/hot100/1715150745498-86.png"></p>
<h4 id="2-两数相加💪"><a href="#2-两数相加💪" class="headerlink" title="2. 两数相加💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a>💪</h4><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>解析：</strong>直接遍历链表就是从个位开始的，符合我们计算加法的习惯顺序。如果是正序存储，那倒要费点脑筋了，可能需要 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">翻转链表</a> 或者使用栈来辅助。这道题主要考察 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">链表双指针技巧</a> 和加法运算过程中对进位的处理。注意这个 <code>carry</code> 变量的处理，在我们手动模拟加法过程的时候会经常用到。<strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是</strong> <strong><code>dummy</code></strong> <strong>节点</strong>。你可以试试，如果不使用 <code>dummy</code> 虚拟节点，代码会稍显复杂，而有了 <code>dummy</code> 节点这个占位符，可以避免处理初始的空指针情况，降低代码的复杂性。</p>
<p><img src="/2024/05/08/hot100/1715150837148-89.png"></p>
<h4 id="19-删除链表的倒数第-N-个结点✅"><a href="#19-删除链表的倒数第-N-个结点✅" class="headerlink" title="19. 删除链表的倒数第 N 个结点✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>✅</h4><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>解析：</strong>要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用。获取单链表的倒数第 <code>k</code> 个节点，就是想考察 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧</a> 中快慢指针的运用，一般都会要求你<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点。</p>
<ol>
<li>我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步</li>
<li>用一个指针 <code>p2</code> 指向链表头节点 <code>head</code></li>
<li>第三步，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时走了 <code>n - k</code> 步，<code>p2</code> 也走了 <code>n - k</code> 步，也就是链表的倒数第 <code>k</code> 个节点。</li>
</ol>
<p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p>
<p><img src="/2024/05/08/hot100/1715151002595-92.png"></p>
<h4 id="24-两两交换链表中的节点💪"><a href="#24-两两交换链表中的节点💪" class="headerlink" title="24. 两两交换链表中的节点💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>💪</h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>解析：</strong>维护多个指针，遍历一遍链表顺便把每两个节点翻转。不过迭代的思路虽然直接，但细节问题会比较多，写起来麻烦。所以直接用递归的方式来写，只要搞明白递归函数的定义，然后利用这个定义就可以完成这道题。</p>
<p><img src="/2024/05/08/hot100/1715151164803-95.png"></p>
<h4 id="25-K-个一组翻转链表😤"><a href="#25-K-个一组翻转链表😤" class="headerlink" title="25. K 个一组翻转链表😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>😤</h4><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>解析：</strong>输入 <code>head</code>，<code>reverseKGroup</code> 函数能够把以 <code>head</code> 为头的这条链表进行翻转。充分利用这个递归函数的定义，把原问题分解成规模更小的子问题进行求解。</p>
<ol>
<li>先反转以 <code>head</code> 开头的 <code>k</code> 个元素。</li>
<li>将第 <code>k + 1</code> 个元素作为 <code>head</code> 递归调用 <code>reverseKGroup</code> 函数。</li>
<li>将上述两个过程的结果连接起来。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715151224859-98.png"></p>
<h4 id="138-随机链表的复制😤"><a href="#138-随机链表的复制😤" class="headerlink" title="138. 随机链表的复制😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a>😤</h4><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p><strong>解析：对于数据结构复制，甭管他怎么变，你就记住最简单的方式：一个哈希表 + 两次遍历</strong>。</p>
<p>第一次遍历专门克隆节点，借助哈希表把原始节点和克隆节点的映射存储起来；第二次专门组装节点，照着原数据结构的样子，把克隆节点的指针组装起来。题目如果让你克隆带随机指针的二叉树，或者克隆图，都是一样的，只不过是遍历的方式从 for 循环迭代遍历变成 <code>traverse</code> 递归函数遍历罢了。</p>
<p><img src="/2024/05/08/hot100/1715151312271-101.png"></p>
<h4 id="148-排序链表😡"><a href="#148-排序链表😡" class="headerlink" title="148. 排序链表😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a>😡</h4><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>解析：归并排序（递归法）</strong></p>
<ul>
<li>分割 <code>cut</code> 环节： 找到当前链表中点，并从 中点 将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）；</li>
</ul>
<ol>
<li>我们使用 <code>fast,slow</code> 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li>
<li>找到中点 <code>slow</code> 后，执行 <code>slow.next = None</code> 将链表切断。</li>
<li>递归分割时，输入当前链表左端点 <code>head</code> 和中心节点 <code>slow</code> 的下一个节点 <code>tmp</code>。</li>
<li><code>cut</code> 递归终止条件： 当 <code>head.next == None</code> 时，说明只有一个节点了，直接返回此节点。</li>
</ol>
<ul>
<li>合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。</li>
</ul>
<ol>
<li>双指针法合并，建立辅助 <code>ListNode h</code> 作为头部。</li>
<li>设置两指针 <code>left, right</code> 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助<code>ListNode h</code> 作为头部的下个节点 <code>h.next</code>。</li>
</ol>
<p> <img src="/2024/05/08/hot100/1715151366626-104.png"></p>
<p><img src="/2024/05/08/hot100/1715151372102-107.png"></p>
<h4 id="23-合并-K-个升序链表😡"><a href="#23-合并-K-个升序链表😡" class="headerlink" title="23. 合并 K 个升序链表😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a>😡</h4><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>解析：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表</a> 的延伸，利用 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列（二叉堆）</a> 进行节点排序即可。</strong></p>
<p><img src="/2024/05/08/hot100/1715151428869-110.png"></p>
<h4 id="146-LRU-缓存😡"><a href="#146-LRU-缓存😡" class="headerlink" title="146. LRU 缓存😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a>😡</h4><p>请你设计并实现一个满足  <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>解析：</strong></p>
<p>要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 <code>O(1)</code>，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p>
<ol>
<li>显然 <code>cache</code> 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</li>
<li>我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</li>
<li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢，所以结合二者的长处，可以形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>：</p>
<p><img src="/2024/05/08/hot100/1715151473035-113.png"></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="94-二叉树的中序遍历✅"><a href="#94-二叉树的中序遍历✅" class="headerlink" title="94. 二叉树的中序遍历✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>✅</h4><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的</em> <em><strong>中序</strong></em> <em>遍历</em> 。</p>
<p><strong>解析：</strong>动态规划思路的核心在于明确并利用函数的定义分解问题，中序遍历结果的特点是 <code>root.val</code> 在中间，左右子树在两侧。回溯算法的核心很简单，就是 <code>traverse</code> 函数遍历二叉树。</p>
<p><img src="/2024/05/08/hot100/1715152099604-116.png"></p>
<h4 id="104-二叉树的最大深度✅"><a href="#104-二叉树的最大深度✅" class="headerlink" title="104. 二叉树的最大深度✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>✅</h4><p>给定一个二叉树 <code>root</code> ，返回其最大深度。二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><img src="/2024/05/08/hot100/1715152310679-119.png"></p>
<h4 id="226-翻转二叉树✅"><a href="#226-翻转二叉树✅" class="headerlink" title="226. 翻转二叉树✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a>✅</h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><img src="/2024/05/08/hot100/1715152364144-122.png"></p>
<h4 id="101-对称二叉树✅"><a href="#101-对称二叉树✅" class="headerlink" title="101. 对称二叉树✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>✅</h4><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><img src="/2024/05/08/hot100/1715152421655-125.png"></p>
<h4 id="543-二叉树的直径💪"><a href="#543-二叉树的直径💪" class="headerlink" title="543. 二叉树的直径💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>💪</h4><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p><strong>解析：</strong>所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。但是由于 <code>maxDepth</code> 也是递归函数，所以上述方式时间复杂度较高。这题类似 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-leaves-of-binary-tree">寻找二叉树的叶子节点</a>，需要灵活运用二叉树的后序遍历，在 <code>maxDepth</code> 的后序遍历位置顺便计算最大直径。</p>
<p><img src="/2024/05/08/hot100/1715152947297-128.png"></p>
<h4 id="102-二叉树的层序遍历💪"><a href="#102-二叉树的层序遍历💪" class="headerlink" title="102. 二叉树的层序遍历💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>💪</h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>解析：</strong>层序遍历的一般写法，通过一个 while 循环控制从上向下一层层遍历，for 循环控制每一层从左向右遍历。</p>
<p><img src="/2024/05/08/hot100/1715153020021-131.png"></p>
<h4 id="108-将有序数组转换为二叉搜索树✅"><a href="#108-将有序数组转换为二叉搜索树✅" class="headerlink" title="108. 将有序数组转换为二叉搜索树✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a>✅</h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。<strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p>
<p><strong>解析：</strong>选择中间位置左边的数字作为根节点，则根节点的下标为 <code>mid = left + ((right - left) &gt;&gt; 1)</code>。</p>
<p><img src="/2024/05/08/hot100/1715153155187-134.png"></p>
<h4 id="98-验证二叉搜索树💪"><a href="#98-验证二叉搜索树💪" class="headerlink" title="98. 验证二叉搜索树💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>💪</h4><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>解析：误区：</strong>BST 不是左小右大么，那我只要检查 <code>root.val &gt; root.left.val</code> 且 <code>root.val &lt; root.right.val</code> 不就行了？</p>
<p>这样是不对的，因为 BST 左小右大的特性是指 <code>root.val</code> 要比左子树的所有节点都更大，要比右子树的所有节点都小，你只检查左右两个子节点当然是不够的。</p>
<p><img src="/2024/05/08/hot100/1715153190542-137.png"></p>
<h4 id="230-二叉搜索树中第K小的元素💪"><a href="#230-二叉搜索树中第K小的元素💪" class="headerlink" title="230. 二叉搜索树中第K小的元素💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>💪</h4><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>解析：BST 的中序遍历结果是有序的（升序），所以用一个外部变量记录中序遍历结果第<code>k</code> 个元素即是第 <code>k</code> 小的元素。</strong></p>
<p><img src="/2024/05/08/hot100/1715153221470-140.png"></p>
<h4 id="199-二叉树的右视图💪"><a href="#199-二叉树的右视图💪" class="headerlink" title="199. 二叉树的右视图💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a>💪</h4><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>解析：</strong>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p>
<p><img src="/2024/05/08/hot100/1715153277576-143.png"></p>
<h4 id="114-二叉树展开为链表💪"><a href="#114-二叉树展开为链表💪" class="headerlink" title="114. 二叉树展开为链表💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>💪</h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin">先序遍历</a></strong> 顺序相同。</li>
</ul>
<p><strong>解析：</strong>明确递归函数的定义，然后利用这个定义，这题就属于后者，<code>flatten</code> 函数的定义如下：<strong>给</strong> <strong><code>flatten</code> 函数输入一个节点 <code>root</code>，那么以<code>root</code>为根的二叉树就会被拉平为一条链表</strong>。如何利用这个定义来完成算法？你想想怎么把以 <code>root</code> 为根的二叉树拉平为一条链表？很简单，以下流程：</p>
<ol>
<li>将 <code>root</code> 的左子树和右子树拉平。</li>
<li>将 <code>root</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</li>
</ol>
<p>至于如何把 <code>root</code> 的左右子树拉平，不用你操心，<code>flatten</code> 函数的定义就是这样，交给他做就行了。</p>
<p><img src="/2024/05/08/hot100/1715153359230-146.png"></p>
<h4 id="105-从前序与中序遍历序列构造二叉树😤"><a href="#105-从前序与中序遍历序列构造二叉树😤" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>😤</h4><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>解析：前序遍历结果第一个就是根节点的值，然后再根据中序遍历结果确定左右子树的节点。</strong></p>
<p><img src="/2024/05/08/hot100/1715153443885-149.png"></p>
<h4 id="437-路径总和-III😤"><a href="#437-路径总和-III😤" class="headerlink" title="437. 路径总和 III😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a>😤</h4><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。<strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>解析：</strong>我们利用先序遍历二叉树，记录下根节点 <code>root</code> 到当前节点 <code>p</code> 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 <code>curr</code> 减去 <code>targetSum</code>。</p>
<ul>
<li>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 <code>0</code>。</li>
<li>假设根节点为 <code>root</code>，我们当前刚好访问节点 <code>node</code>，则此时从根节点 <code>root</code> 到节点 <code>node</code> 的路径（无重复节点）刚好为 <code>root→p1→p2→…→pk→node</code>，此时我们可以已经保存了节点<code> p1,p2,p3,…,pk</code>的前缀和，并且计算出了节点 <code>node</code> 的前缀和。</li>
<li>假设当前从根节点 <code>root</code> 到节点 <code>node</code> 的前缀和为 <code>curr</code>，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 <code>curr−targetSum</code>。假设从根节点 <code>root</code> 到节点 <code>node</code> 的路径中存在节点 <code>pi</code> 到根节点 <code>root</code> 的前缀和为 <code>curr−targetSum</code>，则节点 <code>pi+1</code>到 <code>node</code> 的路径上所有节点的和一定为 <code>targetSum</code>。</li>
<li>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</li>
</ul>
<p><img src="/2024/05/08/hot100/1715153496446-152.png"></p>
<h4 id="236-二叉树的最近公共祖先😤"><a href="#236-二叉树的最近公共祖先😤" class="headerlink" title="236. 二叉树的最近公共祖先😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>😤</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>解析：</strong>先给出递归函数的定义：给该函数输入三个参数 <code>root</code>，<code>p</code>，<code>q</code>，它会返回一个节点：</p>
<ul>
<li>情况 1，如果 <code>p</code> 和 <code>q</code> 都在以 <code>root</code> 为根的树中，函数返回的即使 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</li>
<li>情况 2，那如果 <code>p</code> 和 <code>q</code> 都不在以 <code>root</code> 为根的树中怎么办呢？函数理所当然地返回 <code>null</code> 呗。</li>
<li>情况 3，那如果 <code>p</code> 和 <code>q</code> 只有一个存在于 <code>root</code> 为根的树中呢？函数就会返回那个节点。</li>
</ul>
<p>根据这个定义，分情况讨论：</p>
<ul>
<li>情况 1，如果 <code>p</code> 和 <code>q</code> 都在以 <code>root</code> 为根的树中，那么 <code>left</code> 和 <code>right</code> 一定分别是 <code>p</code> 和 <code>q</code>（从 base case 看出来的）。</li>
<li>情况 2，如果 <code>p</code> 和 <code>q</code> 都不在以 <code>root</code> 为根的树中，直接返回 <code>null</code>。</li>
<li>情况 3，如果 <code>p</code> 和 <code>q</code> 只有一个存在于 <code>root</code> 为根的树中，函数返回该节点。</li>
</ul>
<p><img src="/2024/05/08/hot100/1715153527762-155.png"></p>
<h4 id="124-二叉树中的最大路径和😡"><a href="#124-二叉树中的最大路径和😡" class="headerlink" title="124. 二叉树中的最大路径和😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>😡</h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。<strong>路径和</strong> 是路径中各节点值的总和。给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<p><strong>解析：</strong>考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p>
<p>具体而言，该函数的计算如下:</p>
<ul>
<li>空节点的最大贡献值等于 <code>0</code>。</li>
<li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</li>
</ul>
<p>上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p>
<p>根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p>
<p><img src="/2024/05/08/hot100/1715153555321-158.png"></p>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="200-岛屿数量✅"><a href="#200-岛屿数量✅" class="headerlink" title="200. 岛屿数量✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a>✅</h4><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>解析：</strong>岛屿系列问题可以用 DFS/BFS 算法或者 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">Union-Find 并查集算法</a> 来解决。用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。如何使用 DFS 算法遍历二维数组？你把二维数组中的每个格子看做「图」中的一个节点，这个节点和周围的四个节点连通，这样二维矩阵就被抽象成了一幅网状的「图」。为什么每次遇到岛屿，都要用 DFS 算法把岛屿「淹了」呢？主要是为了省事，避免维护 <code>visited</code> 数组。<a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E5%9B%BE">图算法遍历基础</a> 说了，遍历图是需要 <code>visited</code> 数组记录遍历过的节点防止走回头路。因为 <code>dfs</code> 函数遍历到值为 <code>0</code> 的位置会直接返回，所以只要把经过的位置都设置为 <code>0</code>，就可以起到不走回头路的作用。</p>
<p><img src="/2024/05/08/hot100/1715153679129-161.png"></p>
<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回</em> <em><code>-1</code></em> 。</p>
<p><strong>解析：</strong></p>
<h4 id="207-课程表😡"><a href="#207-课程表😡" class="headerlink" title="207. 课程表😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a>😡</h4><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [a(i), b(i)]</code> ，表示如果要学习课程 <code>a(i)</code> 则 <strong>必须</strong> 先学习课程  <code>b(i)</code>( )。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>解析：</strong>只要会遍历图结构，就可以判断环了。</p>
<p>利用布尔数组 <code>onPath</code>，如果遍历过程中发现下一个即将遍历的节点已经被标记为 true，说明遇到了环（可以联想贪吃蛇咬到自己的场景）。</p>
<p><img src="/2024/05/08/hot100/1715153728009-164.png"></p>
<p><img src="/2024/05/08/hot100/1715153748879-167.png"></p>
<h4 id="208-实现-Trie-前缀树-💀"><a href="#208-实现-Trie-前缀树-💀" class="headerlink" title="208. 实现 Trie (前缀树)💀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a>💀</h4><p>**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>解析：</strong></p>
<p><code>Trie</code>，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组 <code>children</code>。对于本题而言，数组长度为 <code>26</code>，即小写英文字母的数量。此时 <code>children[0]</code> 对应小写字母 <code>a</code>，<code>children[1]</code> 对应小写字母 <code>b，…，children[25]</code> 对应小写字母 <code>z</code>。</li>
<li>布尔字段 <code>isEnd</code>，表示该节点是否为字符串的结尾。</li>
</ul>
<p>插入字符串：我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li>
<li>子节点不存在。创建一个新的子节点，记录在 children\textit{children}children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li>
</ul>
<p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p>
<p>查找前缀：从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li>
<li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li>
</ul>
<p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p>
<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd\textit{isEnd}isEnd 为真，则说明字典树中存在该字符串。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="46-全排列✅"><a href="#46-全排列✅" class="headerlink" title="46. 全排列✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a>✅</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><img src="/2024/05/08/hot100/1715153807653-170.png"></p>
<h4 id="78-子集💪"><a href="#78-子集💪" class="headerlink" title="78. 子集💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a>💪</h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>解析：</strong>本质上子集问题就是遍历一棵回溯树。</p>
<p><img src="/2024/05/08/hot100/1715153855458-173.png"></p>
<h4 id="17-电话号码的字母组合💪"><a href="#17-电话号码的字母组合💪" class="headerlink" title="17. 电话号码的字母组合💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>💪</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2024/05/08/hot100/1715153890701-176.png"></p>
<h4 id="39-组合总和💪"><a href="#39-组合总和💪" class="headerlink" title="39. 组合总和💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a>💪</h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>解析：</strong>这道题的关键在于 <code>candidates</code> 中的元素可以复用多次，体现在代码中是下面这段：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(int[] candidates, int start, int target, int sum) {</span><br><span class="line">    // 回溯算法框架</span><br><span class="line">    for (int i = start; i &lt; candidates.length; i++) {</span><br><span class="line">        // 选择 candidates[i]</span><br><span class="line">        backtrack(candidates, i, target, sum);</span><br><span class="line">        // 撤销选择 candidates[i]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/05/08/hot100/1715153920145-179.png"></p>
<h4 id="22-括号生成💪"><a href="#22-括号生成💪" class="headerlink" title="22. 括号生成💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a>💪</h4><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>解析：</strong>本题可以改写为：现在有 <code>2n</code> 个位置，每个位置可以放置字符 <code>(</code> 或者 <code>)</code>，组成的所有括号组合中，有多少个是合法的？这就是典型的回溯算法提醒，暴力穷举就行了。</p>
<p>不过为了减少不必要的穷举，我们要知道合法括号串有以下性质：</p>
<ol>
<li><strong>一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解</strong>。</li>
<li><strong>对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量</strong>。</li>
</ol>
<p>因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。用 <code>left</code> 记录还可以使用多少个左括号，用 <code>right</code> 记录还可以使用多少个右括号，就可以直接套用 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">回溯算法套路框架</a> 了。</p>
<p><img src="/2024/05/08/hot100/1715153972291-182.png"></p>
<h4 id="79-单词搜索😤"><a href="#79-单词搜索😤" class="headerlink" title="79. 单词搜索😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a>😤</h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>解析：</strong>我们要对已经匹配过的字符做标记，比如用 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E5%9B%BE">图论算法基础</a> 中讲到的 <code>visited</code> 数组，或者使用其他方法标记 <code>board</code> 中已经匹配过的字符。用加负号的方式标记已经匹配过的字符，来避免走回头路。</p>
<p><img src="/2024/05/08/hot100/1715153991617-185.png"></p>
<h4 id="131-分割回文串😤"><a href="#131-分割回文串😤" class="headerlink" title="131. 分割回文串😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a>😤</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><img src="/2024/05/08/hot100/1715153991617-186.png"></p>
<h4 id="51-N-皇后😡"><a href="#51-N-皇后😡" class="headerlink" title="51. N 皇后😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a>😡</h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n</strong> <strong>皇后问题</strong> 的解决方案。每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<p><strong>解析：</strong>N 皇后问题就是一个决策问题：对于每一行，我应该选择在哪一列防止皇后呢？</p>
<p><img src="/2024/05/08/hot100/1715153991618-187.png"></p>
<p><img src="/2024/05/08/hot100/1715153991618-188.png"></p>
<p><img src="/2024/05/08/hot100/1715153991618-189.png"></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="35-搜索插入位置✅"><a href="#35-搜索插入位置✅" class="headerlink" title="35. 搜索插入位置✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a>✅</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>解析：考察搜索左侧边界的二分算法的细节理解</strong></p>
<p><strong>当目标元素</strong> <strong><code>target</code></strong> <strong>不存在数组</strong> <strong><code>nums</code></strong> <strong>中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读</strong>：</p>
<ol>
<li>返回的这个值是 <code>nums</code> 中大于等于 <code>target</code> 的最小元素索引。</li>
<li>返回的这个值是 <code>target</code> 应该插入在 <code>nums</code> 中的索引位置。</li>
<li>返回的这个值是 <code>nums</code> 中小于 <code>target</code> 的元素个数。</li>
</ol>
<p>比如在有序数组 <code>nums = [2,3,5,7]</code> 中搜索 <code>target = 4</code>，搜索左边界的二分算法会返回 2，你带入上面的说法，都是对的。</p>
<p><img src="/2024/05/08/hot100/1715154069099-200.png"></p>
<h4 id="74-搜索二维矩阵✅"><a href="#74-搜索二维矩阵✅" class="headerlink" title="74. 搜索二维矩阵✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a>✅</h4><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>解析：</strong>只要知道二维数组的的行数 <code>m</code> 和列数 <code>n</code>，二维数组的坐标 <code>(i, j)</code> 可以映射成一维的 <code>index = i * n + j</code>；反过来也可以通过一维 <code>index</code> 反解出二维坐标 <code>i = index / n, j = index % n</code>。</p>
<p><img src="/2024/05/08/hot100/1715154069099-201.png"></p>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置💪"><a href="#34-在排序数组中查找元素的第一个和最后一个位置💪" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>💪</h4><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>解析：</strong>二分搜索的难点就在于如何搜索左侧边界和右侧边界，代码的边界的控制非常考验你的微操，这也是很多人知道二分搜索原理但是很难写对代码的原因。</p>
<p><img src="/2024/05/08/hot100/1715154069099-202.png"></p>
<p><img src="/2024/05/08/hot100/1715154069099-203.png"></p>
<h4 id="33-搜索旋转排序数组💪"><a href="#33-搜索旋转排序数组💪" class="headerlink" title="33. 搜索旋转排序数组💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>💪</h4><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>解析：</strong>将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。</p>
<p>这启示我们可以在常规二分查找的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l],nums[mid])</code>，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li>
</ul>
<p><img src="/2024/05/08/hot100/1715154069099-204.png"></p>
<h4 id="153-寻找旋转排序数组中的最小值✅"><a href="#153-寻找旋转排序数组中的最小值✅" class="headerlink" title="153. 寻找旋转排序数组中的最小值✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a>✅</h4><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>解析：</strong>考虑数组中的最后一个元素 <code>x</code>：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 <code>x</code>；而在最小值左侧的元素，它们的值一定都严格大于 <code>x</code>。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p>
<p><img src="/2024/05/08/hot100/1715154069099-205.png"></p>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>解析：</strong></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="20-有效的括号✅"><a href="#20-有效的括号✅" class="headerlink" title="20. 有效的括号✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a>✅</h4><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>解析：</strong>栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。</p>
<p><img src="/2024/05/08/hot100/1715154192997-218.png"></p>
<h4 id="155-最小栈💪"><a href="#155-最小栈💪" class="headerlink" title="155. 最小栈💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a>💪</h4><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>解析：每个元素<strong><strong>入栈</strong></strong>时，还要记下来当前栈中的最小值。比方说，可以用一个额外的栈</strong> <strong><code>minStk</code></strong> <strong>来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。</strong></p>
<p><img src="/2024/05/08/hot100/1715154192997-219.png"></p>
<h4 id="394-字符串解码😤"><a href="#394-字符串解码😤" class="headerlink" title="394. 字符串解码😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a>😤</h4><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>解析：</strong>数字存放在数字栈，字母存放在字母栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。</p>
<p><img src="/2024/05/08/hot100/1715154192997-220.png"></p>
<h4 id="739-每日温度💪"><a href="#739-每日温度💪" class="headerlink" title="739. 每日温度💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>💪</h4><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>解析：</strong></p>
<p>动态规划：</p>
<p><img src="/2024/05/08/hot100/1715154192997-221.png"></p>
<p>单调栈：抽象题意为 : 求解给定序列中每个位置（右边）最近一个比其大的位置，可使用「单调栈」来进行求解。</p>
<p><img src="/2024/05/08/hot100/1715154192997-222.png"></p>
<h4 id="84-柱状图中最大的矩形😡"><a href="#84-柱状图中最大的矩形😡" class="headerlink" title="84. 柱状图中最大的矩形😡"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a>😡</h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>解析：</strong>要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！<strong>栈顶和栈顶的下一个元素以及要<strong><strong>入栈</strong></strong>的三个元素组成了我们要求最大面积的高度和宽度.</strong></p>
<p>主要就是分析清楚如下三种情况：</p>
<p>情况一：当前遍历的元素<code>heights[i]</code>大于栈顶元素<code>heights[st.top()]</code>的情况</p>
<p>情况二：当前遍历的元素<code>heights[i]</code>等于栈顶元素<code>heights[st.top()]</code>的情况</p>
<p>情况三：当前遍历的元素<code>heights[i]</code>小于栈顶元素<code>heights[st.top()]</code>的情况</p>
<p><img src="/2024/05/08/hot100/1715154192997-223.png"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="215-数组中的第K个最大元素✅"><a href="#215-数组中的第K个最大元素✅" class="headerlink" title="215. 数组中的第K个最大元素✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>✅</h4><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <strong><code>k</code></strong> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>解析：</strong></p>
<p>可以把小顶堆 <code>pq</code> 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 <code>k</code> 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 <code>k</code> 个最大元素嘛。当 <code>nums</code> 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 <code>k</code> 个元素，而堆顶元素是堆中最小的元素，也就是「第 <code>k</code> 个最大的元素」。二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 <code>k</code>，所以插入和删除元素的复杂度是 <code>O(logK)</code>，再套一层 for 循环，总的时间复杂度就是 <code>O(NlogK)</code>。</p>
<p><img src="/2024/05/08/hot100/1715154275957-236.png"></p>
<h4 id="347-前-K-个高频元素💪"><a href="#347-前-K-个高频元素💪" class="headerlink" title="347. 前 K 个高频元素💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>💪</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>解析：</strong>首先，肯定要用一个 <code>valToFreq</code> 哈希表把每个元素出现的频率计算出来。然后，这道题就变成了 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素</a>，只不过第 215 题让你求数组中元素值 <code>e</code> 排在第 <code>k</code> 大的那个元素，这道题让你求数组中元素值 <code>valToFreq[e]</code> 排在前 <code>k</code> 个的元素。</p>
<p><img src="/2024/05/08/hot100/1715154275957-237.png"></p>
<h4 id="295-数据流的中位数😤"><a href="#295-数据流的中位数😤" class="headerlink" title="295. 数据流的中位数😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a>😤</h4><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li>
<li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>实现 MedianFinder 类:</p>
<ul>
<li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10(-5)</code> 以内的答案将被接受。</li>
</ul>
<p><strong>解析：</strong>本题的核心思路是使用两个优先级队列。小的倒三角就是个大顶堆，梯形就是个小顶堆，中位数可以通过它们的堆顶元素算出来。</p>
<p>两个优先队列 <code>large</code> 和 <code>small</code> 分别记录大于中位数的数和小于等于中位数的数。当累计添加的数的数量为奇数时，<code>small</code>中的数的数量比 <code>large</code> 多一个，此时中位数为 <code>small</code> 的队头。当累计添加的数的数量为偶数时，两个优先队列中的数的数量相同，此时中位数为它们的队头的平均值。</p>
<p><img src="/2024/05/08/hot100/1715154275957-238.png"></p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="121-买卖股票的最佳时机💪"><a href="#121-买卖股票的最佳时机💪" class="headerlink" title="121. 买卖股票的最佳时机💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>💪</h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>解析：</strong>股票系列问题通用状态转移方程：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">              max( 今天选择 rest,        今天选择 sell       )</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">              max( 今天选择 rest,         今天选择 buy         )</span><br></pre></td></tr></tbody></table></figure>

<p>n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。</p>
<p>特化到 <code>k = 1</code> 的情况，状态转移方程和 base case 如下：</p>
<p>状态转移方程：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], -prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/05/08/hot100/1715154339440-245.png"></p>
<h4 id="55-跳跃游戏✅"><a href="#55-跳跃游戏✅" class="headerlink" title="55. 跳跃游戏✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a>✅</h4><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>解析：</strong>这道题表面上不是求最值，但是可以改一改：<strong>请问通过题目中的跳跃规则，最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。所以解题关键在于求出能够跳到的最远距离。</p>
<p><img src="/2024/05/08/hot100/1715154339440-246.png"></p>
<h4 id="45-跳跃游戏-II💪"><a href="#45-跳跃游戏-II💪" class="headerlink" title="45. 跳跃游戏 II💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a>💪</h4><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>解析：</strong>用 <code>i</code> 和 <code>end</code> 标记了可以选择的跳跃步数，<code>farthest</code> 标记了所有选择 <code>[i..end]</code> 中能够跳到的最远距离，<code>jumps</code> 记录跳跃次数。</p>
<p><img src="/2024/05/08/hot100/1715154339440-247.png"></p>
<h4 id="763-划分字母区间💪"><a href="#763-划分字母区间💪" class="headerlink" title="763. 划分字母区间💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a>💪</h4><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>解析：</strong>在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。可以分为如下两步：</p>
<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li>
</ul>
<p><img src="/2024/05/08/hot100/1715154339440-248.png"></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="70-爬楼梯✅"><a href="#70-爬楼梯✅" class="headerlink" title="70. 爬楼梯✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a>✅</h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>解析：</strong>这题很像 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number">斐波那契数</a>：爬到第 <code>n</code> 级台阶的方法个数等于爬到 <code>n - 1</code> 的方法个数和爬到 <code>n - 2</code> 的方法个数之和。</p>
<p><img src="/2024/05/08/hot100/1715154417457-257.png"></p>
<h4 id="118-杨辉三角💪"><a href="#118-杨辉三角💪" class="headerlink" title="118. 杨辉三角💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a>💪</h4><p>给定一个非负整数 **<code>numRows</code>**，生成「杨辉三角」的前 <em><code>numRows</code></em> 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="/2024/05/08/hot100/1715154417458-258.png"></p>
<h4 id="198-打家劫舍💪"><a href="#198-打家劫舍💪" class="headerlink" title="198. 打家劫舍💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a>💪</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>解析：</strong>假想你就是这个强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。以上已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int res = Math.max(</span><br><span class="line">    // 不抢，去下家</span><br><span class="line">    dp(nums, start + 1),</span><br><span class="line">    // 抢，去下下家</span><br><span class="line">    nums[start] + dp(nums, start + 2)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/05/08/hot100/1715154417458-259.png"></p>
<h4 id="279-完全平方数✅"><a href="#279-完全平方数✅" class="headerlink" title="279. 完全平方数✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a>✅</h4><p>给你一个整数 <code>n</code> ，返回 <em>和为</em> <em><code>n</code></em> <em>的完全平方数的最少数量</em> 。<strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>解析：</strong>题目问和为 <code>n</code> 的平方数的最小数量，那么我可以根据和为 <code>n-1x1, n-2x2, n-3x3...</code> 的平方数的最小数量推导出来。如果这个思路你绕不过来，我再给你变化下就更容易理解了，这个问题完全可以变化成 <a target="_blank" rel="noopener" href="https://labuladong.github.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a> 中讲的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change">322. 零钱兑换</a> 问题：</p>
<p>给你一个目标金额 <code>n</code>，和一个若干硬币的面额 <code>coins = 1,4,9,16...</code>，问你最少需要几枚硬币凑出这个金额（因为包含面值为 1 的硬币，所以不存在凑不出来的情况）</p>
<p><img src="/2024/05/08/hot100/1715154417458-260.png"></p>
<h4 id="322-零钱兑换💪"><a href="#322-零钱兑换💪" class="headerlink" title="322. 零钱兑换💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>💪</h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的。</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>确定 base case</strong>，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</li>
<li><strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</li>
<li><strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</li>
<li><strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715154417458-261.png"></p>
<h4 id="139-单词拆分💪"><a href="#139-单词拆分💪" class="headerlink" title="139. 单词拆分💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a>💪</h4><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>解析：</strong>可类比背包问题</p>
<p><img src="/2024/05/08/hot100/1715154417458-262.png"></p>
<h4 id="300-最长递增子序列✅"><a href="#300-最长递增子序列✅" class="headerlink" title="300. 最长递增子序列✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>✅</h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。<strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>解析：</strong><code>dp</code> 数组的定义：<code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。那么 <code>dp</code> 数组中最大的那个值就是最长的递增子序列长度。</p>
<p><img src="/2024/05/08/hot100/1715154417458-263.png"></p>
<h4 id="152-乘积最大子数组💪"><a href="#152-乘积最大子数组💪" class="headerlink" title="152. 乘积最大子数组💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a>💪</h4><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>解析：</strong>这道题和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray">最大子数组和</a> 有点像，那道题定义的 <code>dp</code> 数组是：<code>dp[i]</code> 记录以 <code>nums[i]</code> 为结尾的「最大子数组和」，从而写出状态转移方程。</p>
<p>这道题可以采用类似的思路，但需要注意的是，在 53 题中，<strong>子数组</strong> <strong><code>nums[0..i]</code></strong> <strong>的最大元素和是由</strong> <strong><code>nums[0..i-1]</code></strong> <strong>的最大元素和推导出的</strong>，但本题变成子数组的乘积则不一定。</p>
<p>比如 <code>nums[i] = -1</code>，<code>nums[0..i-1]</code> 子数组的<strong>最大</strong>元素乘积为 10，那么我能不能说 <code>nums[0..i]</code> 的最大元素乘积为 <code>max(-1, -1 * 10) = -1</code> 呢？其实不行，因为可能<code>nums[0..i-1]</code> 子数组的<strong>最小</strong>元素乘积为 -6，那么 <code>nums[0..i]</code> 的最大元素乘积应该为 max(-1, -1 * 10, -1 * -6) = 6`。</p>
<p>所以这道题和 53 题的最大区别在于，要同时维护「以 <code>nums[i]</code> 结尾的最大子数组」和「以 <code>nums[i]</code> 结尾的最小子数组」，以便适配 <code>nums[i]</code> 可能为负的情况。</p>
<p><img src="/2024/05/08/hot100/1715154417458-264.png"></p>
<h4 id="416-分割等和子集😤"><a href="#416-分割等和子集😤" class="headerlink" title="416. 分割等和子集😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a>😤</h4><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>解析：</strong>对于这个问题，我们可以先对集合求和，得出 <code>sum</code>，然后把问题转化为背包问题：<strong>给一个可装载重量为</strong> <strong><code>sum / 2</code></strong> <strong>的背包和</strong> <strong><code>N</code></strong> <strong>个物品，每个物品的重量为</strong> **<code>nums[i]</code>**<strong>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p>
<p>第一步要明确两点，「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
<p><code>dp</code> 数组的定义：<code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</p>
<p>根据 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p>
<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p>
<p><img src="/2024/05/08/hot100/1715154417458-265.png"></p>
<h4 id="32-最长有效括号✅"><a href="#32-最长有效括号✅" class="headerlink" title="32. 最长有效括号✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a>✅</h4><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>解析：</strong>一般判断括号串是否合法的算法如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">    if (s.charAt(i) == '(') {</span><br><span class="line">        // 遇到左括号，记录索引</span><br><span class="line">        stk.push(i);</span><br><span class="line">    } else {</span><br><span class="line">        // 遇到右括号</span><br><span class="line">        if (!stk.isEmpty()) {</span><br><span class="line">            // 配对的左括号对应索引，[leftIndex, i] 是一个合法括号子串</span><br><span class="line">            int leftIndex = stk.pop();</span><br><span class="line">            // 这个合法括号子串的长度</span><br><span class="line">            int len = 1 + i - leftIndex;</span><br><span class="line">        } else {</span><br><span class="line">            // 没有配对的左括号</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要一个 <code>dp</code> 数组，记录 <code>leftIndex</code> 相邻合法括号子串的长度，才能得出题目想要的正确结果。</p>
<p><img src="/2024/05/08/hot100/1715154417458-266.png"></p>
<h3 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h3><h4 id="62-不同路径✅"><a href="#62-不同路径✅" class="headerlink" title="62. 不同路径✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a>✅</h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义：从 (0, 0) 到 (x, y) 有 dp(x, y) 条路径</span><br><span class="line">int dp(int x, int y) {if (x == 0 &amp;&amp; y == 0) {return 1;</span><br><span class="line">	}if (x &lt; 0 || y &lt; 0) {return 0;</span><br><span class="line">	}// 状态转移方程：</span><br><span class="line">	// 到达 (x, y) 的路径数等于到达 (x - 1, y) 和 (x, y - 1) 路径数之和    		return dp(x - 1, y) + dp(x, y - 1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/05/08/hot100/1715154579894-287.png"></p>
<h4 id="64-最小路径和💪"><a href="#64-最小路径和💪" class="headerlink" title="64. 最小路径和💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a>💪</h4><p>给定一个包含非负整数的 <em><code>m</code></em><code>x</code><em><code>n</code></em> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>解析：</strong>一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要递归 + 备忘录，也就是动态规划技巧。</p>
<p><code>dp</code> 函数的定义：<strong>从左上角位置</strong> <strong><code>(0, 0)</code></strong> <strong>走到位置</strong> <strong><code>(i, j)</code></strong> <strong>的最小路径和为</strong> **<code>dp(grid, i, j)</code>**<strong>。</strong></p>
<p><img src="/2024/05/08/hot100/1715154579894-288.png"></p>
<h4 id="5-最长回文子串😤"><a href="#5-最长回文子串😤" class="headerlink" title="5. 最长回文子串😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a>😤</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>解析：寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串</strong>，对于最长回文子串，就是这个意思：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 0 &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    更新答案</span><br></pre></td></tr></tbody></table></figure>

<p>找回文串的关键技巧是传入两个指针 <code>l</code> 和 <code>r</code> 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 0 &lt;= i &lt; len(s):`*`找到以 s[i] 为中心的回文串`* `    palindrome(s, i, i)`*`找到以 s[i] 和 s[i+1] 为中心的回文串`* `    palindrome(s, i, i + 1)` `    更新答案</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/05/08/hot100/1715154579894-289.png"></p>
<h4 id="1143-最长公共子序列😤"><a href="#1143-最长公共子序列😤" class="headerlink" title="1143. 最长公共子序列😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>😤</h4><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>解析：</strong>和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance">编辑距离</a> 同为经典的双字符串动态规划问题。用两个指针 <code>i, j</code> 在两个字符串上游走，这就是「状态」，字符串中的每个字符都有两种「选择」，要么在 <code>lcs</code> 中，要么不在。</p>
<p><code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</p>
<p><img src="/2024/05/08/hot100/1715154579894-290.png"></p>
<h4 id="72-编辑距离😤"><a href="#72-编辑距离😤" class="headerlink" title="72. 编辑距离😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>😤</h4><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将</em> <em><code>word1</code></em> <em>转换成</em> <em><code>word2</code></em> <em>所使用的最少操作数</em>  。你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>解析：</strong>解决两个字符串的动态规划问题，一般都是用两个指针 <code>i, j</code> 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。对于每对儿字符 <code>s1[i]</code> 和 <code>s2[j]</code>，可以有四种操作：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if s1[i] == s2[j]:</span><br><span class="line">    啥都别做（skip）</span><br><span class="line">    i, j 同时向前移动</span><br><span class="line">else:</span><br><span class="line">    三选一：</span><br><span class="line">        插入（insert）</span><br><span class="line">        删除（delete）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></tbody></table></figure>

<p>那么「状态」就是指针 <code>i, j</code> 的位置，「选择」就是上述的四种操作。如果使用自底向上的迭代解法，这样定义 <code>dp</code> 数组：<code>dp[i-1][j-1]</code> 存储 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 的最小编辑距离。<code>dp</code> 数组索引至少是 0，所以索引会偏移一位。</p>
<p><img src="/2024/05/08/hot100/1715154579894-291.png"></p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="136-只出现一次的数字✅"><a href="#136-只出现一次的数字✅" class="headerlink" title="136. 只出现一次的数字✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a>✅</h4><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p><strong>解析：</strong>可以运用异或运算的性质：一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素。</p>
<p><img src="/2024/05/08/hot100/1715154756168-302.png"></p>
<h4 id="169-多数元素✅"><a href="#169-多数元素✅" class="headerlink" title="169. 多数元素✅"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a>✅</h4><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>解析：</strong>存在一个众数，它出现的次数过半，那么如果你把这个众数元素想象成正电粒子，其他的所有元素都想象成负电粒子，那么它们混合起来会怎样？<strong>在正负粒子混合的过程中，整体的带电性可能在正负间波动，但最终的结果一定是正电</strong>。</p>
<p><img src="/2024/05/08/hot100/1715154756168-303.png"></p>
<h4 id="75-颜色分类💪"><a href="#75-颜色分类💪" class="headerlink" title="75. 颜色分类💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a>💪</h4><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p><strong>解析：双指针</strong></p>
<p>具体地，我们用指针 <code>p0</code>来交换 <code>0</code>，<code>p1</code>来交换 <code>1</code>，初始值都为 <code>0</code>。当我们从左向右遍历整个数组时：</p>
<ul>
<li>如果找到了 <code>1</code>，那么将其与 <code>nums[p1]</code>进行交换，并将 <code>p1</code>向后移动一个位置，这与方法一是相同的；</li>
<li>如果找到了 <code>0</code>，那么将其与 <code>nums[p0]</code>进行交换，并将 <code>p0</code>向后移动一个位置。这样做是正确的吗？我们可以注意到，因为连续的 <code>0</code> 之后是连续的 <code>1</code>，因此如果我们将 <code>0</code> 与 <code>nums[p0]</code>进行交换，那么我们可能会把一个 <code>1</code> 交换出去。当 <code>p0&lt;p1</code>时，我们已经将一些 <code>1</code> 连续地放在头部，此时一定会把一个 <code>1</code> 交换出去，导致答案错误。因此，如果 <code>p0&lt;p1</code>，那么我们需要再将 <code>nums[i]</code>与 <code>nums[p1]</code>进行交换，其中 <code>i</code> 是当前遍历到的位置，在进行了第一次交换后，<code>nums[i]</code>的值为 <code>1</code>，我们需要将这个 <code>1</code> 放到「头部」的末端。在最后，无论是否有 <code>p0&lt;p1</code>，我们需要将 <code>p0</code>和 <code>p1</code>均向后移动一个位置，而不是仅将 <code>p0</code>向后移动一个位置。</li>
</ul>
<p><img src="/2024/05/08/hot100/1715154756168-304.png"></p>
<h4 id="31-下一个排列😤"><a href="#31-下一个排列😤" class="headerlink" title="31. 下一个排列😤"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a>😤</h4><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p><strong>解析：</strong>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p>
<ol>
<li>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</li>
<li>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</li>
</ol>
<p><img src="/2024/05/08/hot100/1715154756168-305.png"></p>
<h4 id="287-寻找重复数💪"><a href="#287-寻找重复数💪" class="headerlink" title="287. 寻找重复数💪"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a>💪</h4><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
<p><strong>解析：二分查找</strong></p>
<p><img src="/2024/05/08/hot100/1715154756168-306.png"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">He Xu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xiezi123caicai.github.io/2024/05/08/hot100/">https://xiezi123caicai.github.io/2024/05/08/hot100/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">He Xu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/leecode%E9%A2%98/">
                                    <span class="chip bg-color">leecode题</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '2TCbHQINzryxnsmqLH94khJz-gzGzoHsz',
        appKey: 'fiXGY2a9y9yBnSowrOCJgP8A',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '期待与您交流！'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/05/08/rocketmq/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="RocketMQ">
                        
                        <span class="card-title">RocketMQ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-05-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-category">
                                    消息队列
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">
                        <span class="chip bg-color">中间件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/08/tools-and-frameworks/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="Tools-And-frameworks">
                        
                        <span class="card-title">Tools-And-frameworks</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E9%83%A8%E5%88%86%E6%A1%86%E6%9E%B6/" class="post-category">
                                    工具和部分框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">
                        <span class="chip bg-color">中间件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2916766519"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <span id="year">2024</span>
            <a href="/about" target="_blank">He Xu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/xiezi123caicai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1024626253@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1024626253" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1024626253" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>



    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
