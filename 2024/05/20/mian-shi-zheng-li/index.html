<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试整理, Hexu&#39;s learn blog">
    <meta name="description" content="study">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试整理 | Hexu&#39;s learn blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexu&#39;s learn blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexu&#39;s learn blog</div>
        <div class="logo-desc">
            
            study
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/xiezi123caicai" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/xiezi123caicai" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试整理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/">
                                <span class="chip bg-color">面试整理知识点</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-20
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    42k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    147 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a><strong>什么是反射机制？</strong></h4><p>反射机制是指程序在运行时能获取自身的信息。在Java中，只要给定类的名字，就可以通过反射机制来获取类的所有属性和方法。</p>
<h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有<strong>封装、继承、多态</strong>的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h4 id="Java中创建对象有哪些种方式"><a href="#Java中创建对象有哪些种方式" class="headerlink" title="Java中创建对象有哪些种方式"></a><strong>Java中创建对象有哪些种方式</strong></h4><p>使用new关键字。使用反射机制。使用clone方法。使用反序列化（基于反射机制）。使用方法句柄。使用Unsafe分配内存。</p>
<h4 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h4><p>六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p>
<ol>
<li><strong>byte</strong>：8位、有符号的，以二进制补码表示的整数</li>
<li><strong>short</strong>：16 位、有符号的以二进制补码表示的整数</li>
<li><strong>int</strong>：32位、有符号的以二进制补码表示的整数</li>
<li><strong>long</strong>：64 位、有符号的以二进制补码表示的整数</li>
<li><strong>float</strong>：单精度、32位、符合IEEE 754标准的浮点数</li>
<li><strong>double</strong>：双精度、64 位、符合 IEEE 754 标准的浮点数</li>
<li><strong>boolean</strong>：表示一位的信息</li>
<li><strong>char</strong>：单一的 16 位 Unicode 字符</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Java 不支持多继承，但支持多重继承。子类拥有父类非 private 的属性、方法。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。</p>
<p>三个必要条件：继承。重写。父类引用指向子类对象：<strong>Parent p = new Child();</strong></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</p>
<p>抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>优点：</p>
<ol>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。隐藏信息，实现细节。</li>
</ol>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<ul>
<li>接口不能用于实例化对象。接口没有构造方法。接口中所有的方法必须是抽象方法。接口不能包含成员变量，除了 static 和 final 变量。接口不是被类继承了，而是要被类实现。</li>
</ul>
<h4 id="volatile变量和atomic变量有什么不同"><a href="#volatile变量和atomic变量有什么不同" class="headerlink" title="volatile变量和atomic变量有什么不同?"></a>volatile变量和atomic变量有什么不同?</h4><p><strong>volatile变量</strong>可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用volatile修饰count变量那么count++操作就不是原子性的。<br>而AtomicInteger类提供的<strong>atomic方法</strong>可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h4 id="访问修饰符public，private，protected，以及不写（默认）时的区别？"><a href="#访问修饰符public，private，protected，以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public，private，protected，以及不写（默认）时的区别？"></a>访问修饰符public，private，protected，以及不写（默认）时的区别？</h4><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">当前类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开( public )， 对于不是同一个包中的其他类相当于私有(private)。受保护 (protected) 对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是public 或默认，类的成员(包括内部类) 的修饰符可以是以上四种。</p>
<h4 id="Java有几种文件拷贝方式，哪一种效率最高？"><a href="#Java有几种文件拷贝方式，哪一种效率最高？" class="headerlink" title="Java有几种文件拷贝方式，哪一种效率最高？"></a>Java有几种文件拷贝方式，哪一种效率最高？</h4><ol>
<li>使用java.io包下的库，使用FileInputStream读取，再使用FileOutputStream写出。</li>
<li>使用java.nio包下的库，使用FileInputStream读取，再使用FileOutputStream写出。</li>
<li>Java标准类库本身已经提供了Files.copy 的实现。</li>
</ol>
<p>对于Copy的效率，这个其实与操作系统和配置等情况相关，在传统的文件IO操作里面，我们都是调用操作系统提供的底层标准IO系统调用函数read()、write()，由于内核指令的调用会<strong>使当前用户线程切换到内核态，然后内核线程负责把相应的文件数据读取到内核的IO缓冲区，再把数据从内核I0缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。</strong><br>而NIO里面提供的<strong>NIO transferTo和transfFrom方法，也就是常说的零拷贝实现</strong>。它能够利用现代操作系统底层机制，避免不必要拷贝和上下文切换，因此在性能上表现比较好。</p>
<h4 id="深拷贝和浅拷贝的区别是什么？"><a href="#深拷贝和浅拷贝的区别是什么？" class="headerlink" title="深拷贝和浅拷贝的区别是什么？"></a>深拷贝和浅拷贝的区别是什么？</h4><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制过的新对象。而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</li>
</ul>
<h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些"></a>什么是类加载器，类加载器有哪些</h4><p>类加载器就是把类文件加载到虚拟机中，也就是说通过一个类的全限定名来获取描述该类的二进制字节流。</p>
<p><strong>四种类加载器</strong>：</p>
<ol>
<li>**启动类加载器(Bootstrap ClassLoader)**用来加载 java核心类库，无法被java程序直接引用</li>
<li>**扩展类加载器(extension class loader)**：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类</li>
<li>**系统类加载器(system class loader)**也叫应用类加载器：它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它</li>
<li><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader 类的方式实现</li>
</ol>
<p><strong>什么时候会使用到加载器？</strong></p>
<ul>
<li>new 对象的时候</li>
<li>访问某个类或者接口的静态变量，或者对该静态变量赋值时</li>
<li>调用类的静态方法时</li>
<li>反射</li>
<li>初始化一个类的子类时，其父类首先会被加载</li>
<li>JVM 启动时标明的启动类，也就是文件名和类名相同的那个类</li>
</ul>
<h4 id="new-String-“abc”）到底创建了几个对象？"><a href="#new-String-“abc”）到底创建了几个对象？" class="headerlink" title="new String(“abc”）到底创建了几个对象？"></a>new String(“abc”）到底创建了几个对象？</h4><p>new 关键字，这个关键字是在程序运行时，根据已经加载的系统类 String，在堆内存里面实例化的一个字符串对象。JVM 会拿字面量“abc” 去字符串常量池里面试图去获取它对应的 String 对象引用，如果拿不到，就会在堆内存里面创建一个 abc 的 String 对象。并且把引用保存到字符串常量池里面。后续如果再有字面量“abc”的定义，因为字符串常量池里面已经存在了字面量“abc”的引用，所以只需要从常量池获取对应的引用就可以了，不需要再创建。</p>
<h4 id="String、StringBuffer、StringBuilder-区别"><a href="#String、StringBuffer、StringBuilder-区别" class="headerlink" title="String、StringBuffer、StringBuilder 区别"></a>String、StringBuffer、StringBuilder 区别</h4><p>第一个，可变性。<br>String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p>
<p>第二个，线程安全性。<br>String 是不可变类，所以它是线程安全的。StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用 StringBuilder</p>
<p>第三个，性能方面。<br>String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p>
<p>第四个，存储方面。<br>String 存储在字符串常量池里面。StringBuffer 和 StringBuilder 存储在堆内存空间。</p>
<h4 id="finally-块一定会执行吗？"><a href="#finally-块一定会执行吗？" class="headerlink" title="finally 块一定会执行吗？"></a>finally 块一定会执行吗？</h4><p>finally 语句块在两种情况下不会执行：</p>
<ul>
<li>程序没有进入到 try 语句块因为异常导致程序终止，这个问题主要是开发人员在编写代码的时候，异常捕获的范围不够。</li>
<li>在 try 或者 cache 语句块中，执行了 System.exit(0）语句，导致 JVM 直接退出</li>
</ul>
<h4 id="final、finally、finalize有什么区别"><a href="#final、finally、finalize有什么区别" class="headerlink" title="final、finally、finalize有什么区别"></a>final、finally、finalize有什么区别</h4><ul>
<li>final: 用于声明变量方法或类,使之可变可重写或不可继承。</li>
<li>finally: 异常处理的一部分，用于确保代码块(通常于资源清理)总是执行。</li>
<li>finalize：是Object类的一个方法，用于在对象被垃圾回收前执行清理操作，但通常不推荐使用。</li>
</ul>
<h4 id="为什么重写-equals-就一定要重写-hashCode-方法？"><a href="#为什么重写-equals-就一定要重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 就一定要重写 hashCode() 方法？"></a>为什么重写 equals() 就一定要重写 hashCode() 方法？</h4><p>如果只重写 equals 方法，不重写 hashCode 方法。就有可能导致 a.equals(b）这个表达式成立，但是 hashCode 却不同。那么这个<strong>只重写了 equals 方法的对象，在使用散列集合进行存储的时候就会出现问题。</strong>因为散列结合是使用 hashCode 来计算 key 的存储位置，如果存储两个完全相同的对象，但是有不同的 hashcode 就会导致这两个对象存储在 hash 表的不同位置，当我们想根据这个对象去获取数据的时候，就会出现一个悖论：一个完全相同的对象会存储在 hash 表的两个位置，造成大家约定俗成的规则，出现一些不可预料的错误。</p>
<h4 id="死锁与活锁的区别-，死锁与饥饿的区别？"><a href="#死锁与活锁的区别-，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别 ，死锁与饥饿的区别？"></a>死锁与活锁的区别 ，死锁与饥饿的区别？</h4><p><strong>产生死锁的必要条件</strong>：</p>
<ol>
<li>互斥条件 ： 所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件 ：一个进程因请求资源而阻塞时 ， 对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源 ，在未使用完之前 ，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种首尾相接的循环等待资源关系。</li>
</ol>
<p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断地改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<h4 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h4><p><strong>字节流和字符流</strong>。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流 ， 主要是为了提高性能和使用方便。 关于 Java 的 I/O 需要注意的有两点 ：一是两种对称性（输入和输出的对称性 ，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。</p>
<h4 id="平时是怎么处理异常的"><a href="#平时是怎么处理异常的" class="headerlink" title="平时是怎么处理异常的"></a>平时是怎么处理异常的</h4><p>try-catch-finally：try 块负责监控可能出现异常的代码；catch 块负责捕获可能出现的异常，并进行处理；finally 块负责清理各种资源，不管是否出现异常都会执行；其中 try 块是必须的，catch 和 finally 至少存在一个标准异常处理流程。</p>
<p>在开发过程中会使用到自定义异常，在通常情况下，程序很少会自己抛出异常，因为异常的类名通常也包含了该异常的有用信息，所以在选择抛出异常的时候，应该选择合适的异常类，从而可以明确地描述该异常情况，所以这时候往往都是自定义异常。</p>
<p>自定义异常通常是通过继承 java.lang.Exception 类，如果想自定义 Runtime 异常的话，可以继承java.lang.RuntimeException类，实现一个无参构造和一个带字符串参数的有参构造方法。</p>
<h4 id="Java异常类"><a href="#Java异常类" class="headerlink" title="Java异常类"></a>Java异常类</h4><p>异常类是 Java 编程语言中用于处理运行时错误或异常情况的一组特殊类。这些类继承自 <code>Throwable</code> 类，它是 Java 中所有错误和异常的超类。<code>Throwable</code> 类有两个主要的子类：<code>Error</code> 和 <code>Exception</code>。</p>
<ul>
<li>Error</li>
</ul>
<p><code>Error</code> 类表示严重问题，这些问题通常是 JVM 无法或不应尝试去修复的问题。例如，<code>OutOfMemoryError</code> 表示 JVM 没有足够的内存空间来继续执行程序。通常，应用程序不应该尝试捕获这些错误。</p>
<ul>
<li>Exception</li>
</ul>
<p><code>Exception</code> 类表示可以由应用程序捕获并处理的条件。这些条件在应用程序的正常操作期间可能发生，但不一定导致程序终止。<code>Exception</code> 类进一步分为两个主要子类：<code>RuntimeException</code> 和 <code>Checked Exception</code>。</p>
<ul>
<li>RuntimeException</li>
</ul>
<p><code>RuntimeException</code> 是那些在编译时不需要显式捕获的异常。它们是程序错误，通常表示编程问题，如逻辑错误或无效的输入。例如，<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等都是 <code>RuntimeException</code> 的子类。</p>
<ul>
<li>Checked Exception</li>
</ul>
<p>Checked Exception 是在编译时必须显式捕获或声明的异常。这些异常通常是可预见的，并且应用程序应该采取适当的措施来处理它们。例如，<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等都是 Checked Exception。</p>
<h4 id="String中intern的原理是什么？"><a href="#String中intern的原理是什么？" class="headerlink" title="String中intern的原理是什么？"></a>String中intern的原理是什么？</h4><p>字符串常量池中的常量有两种来源:</p>
<p>1、字量会在编译期先进入到Class常量池，然后再在运行期进去到字符串池,</p>
<p>2、在运行期通过intern将字符串对象手动添加到字符串常量池中。</p>
<p>intern的作用是这样的:</p>
<ol>
<li>如果字符串池中已经存在一个等于该字符串的对象，intern()方法会返回这个已存在的对象的引用。</li>
<li>如果字符串池中没有等于该字符串的对象，intern()方法会将该字符串添加到字符串池中，并返回对新添加的字符串对象的引用。</li>
</ol>
<h4 id="Java中创建对象的过程"><a href="#Java中创建对象的过程" class="headerlink" title="Java中创建对象的过程"></a>Java中创建对象的过程</h4><ol>
<li><strong>类加载</strong>：当使用<code>new</code>关键字来创建一个对象时，首先会检查这个类的信息是否已经被加载到内存中。如果没有加载，就会触发类加载过程。类加载器会加载类的字节码文件到内存中，并创建对应的<code>Class</code>对象。这一步涉及到类的元数据的加载、链接（包括验证、准备、解析）和初始化。</li>
<li><strong>分配<strong><strong>内存</strong></strong>空间</strong>：在JVM的堆内存中为新的对象分配足够的、连续的内存空间。分配的方式取决于堆内存是否规整以及垃圾收集器的类型，一般会有“指针碰撞”和“空闲列表”两种方式。</li>
<li><strong>初始化对象</strong>：在内存分配完之后，JVM会初始化这块内存空间。这包括将内存清零，并设置对象头信息（如对象的哈希码、GC分代年龄等），同时调用对象的构造方法进行初始化。只有在对象的初始化完成后，对象才真正创建完成。</li>
<li><strong>设置对象引用</strong>：JVM会将分配的内存地址赋值给对象的引用变量。这样，通过对象的引用变量，就可以访问对象的属性和方法了。</li>
</ol>
<h4 id="几种集合的排序方式？"><a href="#几种集合的排序方式？" class="headerlink" title="几种集合的排序方式？"></a>几种集合的排序方式？</h4><ul>
<li>实现Comparable：实体类自己实现Comparable接口比较</li>
<li>借助Comparator：借助比较器进行排序</li>
<li>通过Stream：借助Stream的API，底层还是通过Comparable实现的。</li>
</ul>
<h4 id="Set是如何保证元素不重复的"><a href="#Set是如何保证元素不重复的" class="headerlink" title="Set是如何保证元素不重复的"></a>Set是如何保证元素不重复的</h4><ol>
<li>TreeSet是二叉树实现的，TreeSet中的数据是自动排好序的，允许放入null值；底层基于TreeMap的KeySet()，TreeMap是基于红黑树实现</li>
<li>HashSet是哈希表实现的，HashSet中的数据是无序的，可以放入null，只能放入一个null，两者中的值都不能重复，就如数据库中唯一束；底层基于HashMap。计算元素的hashcode值</li>
</ol>
<h4 id="为什么底层数组要使用transient"><a href="#为什么底层数组要使用transient" class="headerlink" title="为什么底层数组要使用transient"></a>为什么底层数组要使用transient</h4><p>Arayis实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。所以，为了避免Java自带的序列化机制造成的空间浪费，把数组定义为transient，然后重写<strong>writeObject和readObject</strong>来实现序列化操作。</p>
<h4 id="hash冲突通常怎么解决？"><a href="#hash冲突通常怎么解决？" class="headerlink" title="hash冲突通常怎么解决？"></a>hash冲突通常怎么解决？</h4><ol>
<li>开放地址法：发生冲突，寻找下一个空的散射地址，只要散射列表足够大，空的散射地址总能找到。</li>
<li>链地址法：每个哈希桶(bucket)指向一个链表。 当发生冲突时，新的元素将被添加到这个链表的末尾。</li>
<li>再哈希法：用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li>
<li>建立公共溢出区：建立基本表和溢出表</li>
<li>一致性hash：分布式系统</li>
</ol>
<h4 id="HashMap的hash方法是如何实现的？"><a href="#HashMap的hash方法是如何实现的？" class="headerlink" title="HashMap的hash方法是如何实现的？"></a>HashMap的hash方法是如何实现的？</h4><p>只要调用Object对象的hashCode方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。他的具体实现主要由两个方法int hash(Object k)和int indexFor(int h, int length)来实现的。</p>
<ol>
<li>使用位运算(&amp;)来代替取模运算(%)，因为位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</li>
<li>对hashcode进行扰动计算， 防止不同hashCode的高位不同但低位相同导致的hash冲突。 简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。</li>
</ol>
<h4 id="HashMap的remove方法是如何实现的？"><a href="#HashMap的remove方法是如何实现的？" class="headerlink" title="HashMap的remove方法是如何实现的？"></a>HashMap的remove方法是如何实现的？</h4><ol>
<li>首先，remove方法会计算键的哈希值，并通过哈希值计算出在数组中的索引位置。</li>
<li>如果该位置上的元素为空，说明没有找到对应的键值对，直接返回null。</li>
<li>如果该位置上的元素不为空，检查是否与当前键相等，如果相等，那么将该键值对删除，并返回该键值对的值。</li>
<li>如果该位置上的元素不为空，但也与当前键不相等，那么就需要在链表或红黑树中继续查找。</li>
<li>遍历链表或者红黑树，查找与当前键相等的键值对，找到则将该键值对删除，返回该键值对的值，否则返回null</li>
</ol>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><h4 id="select和epoll的区别？"><a href="#select和epoll的区别？" class="headerlink" title="select和epoll的区别？"></a>select和epoll的区别？</h4><p>select和epoll都是I/O多路复用的机制，它们可以让一个进程监听多个文件描述符的 IO事件或者连接事件，只要其中任意一个或多个文件描述符就绪，就会触发阻塞唤醒，使得应用程序可以直接进行数据的读取或者写入。它们的区别主要有几个方面：</p>
<ol>
<li><strong>select是基于轮询的机制</strong>，它需要遍历整个监听集合，直到找到就绪的文件描述符。<strong>而epoll是基于事件通知的机制</strong>，它只需要遍历当前就绪的文件描述符集合，大大减少了遍历的次数和开销。</li>
<li>select的监听集合大小有限，一般受到操作系统的限制，而epoll没有这个限制，可以监听大量的文件描述符。</li>
<li>在处理大量文件描述符时，select的性能随着监听集合的增大而逐渐下降，而epoll的性能则能够保持稳定。</li>
<li>在多线程环境下，select需要将监听集合传递给每个线程，而epoll可以在一个线程中处理多个文件描述符，避免了线程间的切换和数据复制等开销。</li>
</ol>
<p>epoll相比与select在性能和扩展性上有很大优势，企业上用的最多的还是epoll。而在处理少量文件描述符或需要跨平台支持的情况下，select是更好的选择。</p>
<h4 id="什么是IO多路复用的机制"><a href="#什么是IO多路复用的机制" class="headerlink" title="什么是IO多路复用的机制?"></a>什么是IO多路复用的机制?</h4><p>I0多路复用机制，核心思想是<strong>让单个线程去监视多个连接，一旦某个连接就绪，也就是触发了读/写事件</strong>。就通知应用程序，去获取这个就绪的连接进行读写操作。也就是在应用程序里面可以使用单个线程同时处理多个客户端连接，在对系统资源消耗较少的情况下提升服务端的链接处理数量。</p>
<p>常用的IO多路复用机制的实现方式：select，epoll，poll。其中<strong>select和poll是基于轮询的方式去获取就绪链接</strong>。而<strong>epoll是基于事件驱动的方式获取就绪连接</strong>。</p>
<h4 id="什么是AIO、BIO和NIO？"><a href="#什么是AIO、BIO和NIO？" class="headerlink" title="什么是AIO、BIO和NIO？"></a>什么是AIO、BIO和NIO？</h4><p><strong>BIO (Blocking I/O)</strong> :同步阻塞I/O, DK1.4之前的传统IO模型。线程发起IO请求后,一直塞, 直到缓冲区数据就绪后，再进入下一步操作。</p>
<p><strong>NIO (Non-Blocking I/O)</strong> :同步非阻塞IO,线程发起IO请求后,不要阻塞,立即返回。用户线程不原地等待IO缓冲区，可以先做一其他操作,只需要定时轮询检查I0缓冲区数据是否就绪即可。</p>
<p><strong>AIO ( Asynchronous I/O)</strong> :异步非阻塞I/O模型。线程发起IO请求后,不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="submit-和execute-方法有什么区别"><a href="#submit-和execute-方法有什么区别" class="headerlink" title="submit()和execute()方法有什么区别"></a>submit()和execute()方法有什么区别</h4><p>两个方法都可以向线程池提交任务, <strong>execute()方法</strong>的返回类型是void ,它定义在Executor接口中。</p>
<p>而<strong>submit()方法</strong>可以返回持有计算结果的Future 对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像 Thread Pool Executor和ScheduledThread PoolExecutor都有这些方法。</p>
<h4 id="在Java中Executor和Executors的区别"><a href="#在Java中Executor和Executors的区别" class="headerlink" title="在Java中Executor和Executors的区别?"></a>在Java中Executor和Executors的区别?</h4><p><strong>Executors工具类</strong>的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</p>
<p><strong>Executor接口对象</strong>能执行我们的线程任务。使用Thread Pool Executor可以创建自定义线程池。</p>
<h4 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h4><p>Callable接口类似于Runnable ，但是<strong>Runnable 不会返回结果，并且无法抛出返回结果的异常</strong>，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future 拿到，也就是说，<strong>Future 可以拿到异步执行任务的返回值。</strong>可以认为是带有回调的Runnable。Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable 用于产生结果，Future用于获取结果。</p>
<h4 id="什么是FutureTask-使用ExecutorService-启动任务。"><a href="#什么是FutureTask-使用ExecutorService-启动任务。" class="headerlink" title="什么是FutureTask? 使用ExecutorService 启动任务。"></a>什么是FutureTask? 使用ExecutorService 启动任务。</h4><p>在Java并发程序中<strong>FutureTask 表示一个可以取消的异步运算。</strong>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。<strong>一个FutureTask 对象可以对调用了Callable和Runnable 的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</strong></p>
<h4 id="ThreadLocal-是什么？它的实现原理呢？"><a href="#ThreadLocal-是什么？它的实现原理呢？" class="headerlink" title="ThreadLocal 是什么？它的实现原理呢？"></a>ThreadLocal 是什么？它的实现原理呢？</h4><ol>
<li>ThreadLocal 是一种线程隔离机制，它<strong>提供了多线程环境下对于共享变量访问的安全性</strong>。</li>
<li>在多线程访问共享变量的场景中，一般的解决办法是对共享变量加锁，从而保证在同一时刻只有一个线程能够对共享变量进行更新。但是加锁会带来性能的下降，所以 ThreadLocal 用了一种<strong>空间换时间</strong>的设计思想，也就是说在每个线程里面，都有一个容器来存储共享变量的副本，然后每个线程只对自己的变量副本来做更新操作，这样既解决了线程安全问题，又避免了多线程竞争加锁的开销。</li>
<li>ThreadLocal 的具体实现原理是，在 Thread 类里面有一个成员变量 ThreadLocalMap，它专门来存储当前线程的共享变量副本，后续这个线程对于共享变量的操作，都是从这个 ThreadLocalMap里面进行变更，不会影响全局共享变量的值。</li>
</ol>
<h4 id="ThreadLocal如何做到线程之间数据隔离的？"><a href="#ThreadLocal如何做到线程之间数据隔离的？" class="headerlink" title="ThreadLocal如何做到线程之间数据隔离的？"></a>ThreadLocal如何做到线程之间数据隔离的？</h4><p>由于每个线程操作的都是它自己的 <code>ThreadLocalMap</code>，这个 <code>ThreadLocalMap</code> 是线程私有的，即每个线程都有自己独立的 <code>ThreadLocalMap</code> 实例。因此 <code>ThreadLocal</code> 的操作是线程安全的。</p>
<h4 id="Threadlocal怎么配合线性池使用？"><a href="#Threadlocal怎么配合线性池使用？" class="headerlink" title="Threadlocal怎么配合线性池使用？"></a>Threadlocal怎么配合线性池使用？</h4><p><code>ThreadLocal</code> 与线程池（如 <code>ExecutorService</code> 或 <code>ThreadPoolExecutor</code>）配合使用时，可以确保每个线程在处理任务时都有它自己的独立变量副本，从而避免线程间的数据干扰。这在线程池处理需要保存线程状态或线程特有数据的场景中非常有用。</p>
<p>但是在线程复用的情况下，<code>threadLocal</code>并不能保证按照预期执行，很有可能出现数据错乱。原因就是线程池中的线程在还未销毁的情况下，新的请求进来，会继续复用线程池中的线程，而这些线程在之前处理的过程中，对应的<code>threadLocal</code>有可能已经有值，导致出错。正确姿势是在<code>threadLocal</code>变量使用之后，调用<code>remove()</code>方法。</p>
<h4 id="四种线程池拒绝策略"><a href="#四种线程池拒绝策略" class="headerlink" title="四种线程池拒绝策略"></a>四种线程池拒绝策略</h4><ul>
<li>ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。</li>
<li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 </li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</li>
</ul>
<h4 id="工作队列的种类"><a href="#工作队列的种类" class="headerlink" title="工作队列的种类"></a>工作队列的种类</h4><ol>
<li><strong>ArrayBlockingQueue 基于数组的有界阻塞队列</strong>，按FIFO排序，当线程数量达到线程池核心线程数（corePoolSize）时，新的任务会放入队列的队尾，当队列满了时，会创建一个新的线程，当线程数达到线程池最大线程数（MaxnumPoolSize）时会执行拒绝策略。</li>
<li><strong>LinkedBlockingQueue 基于链表的无界阻塞队列</strong>（最大容量为Integer.MAX），按FIFO排序，当线程数达到线程池核心线程数（corePoolSize）时，新的任务会进入队列等待而不会创建新的线程直到队列达到Integer.MAX</li>
<li><strong>SynchronousQueue 不缓存任务的阻塞队列</strong>，直接执行任务，没有线程可以用时会新建线程，直到线程数达到线程池最大线程数（MaxnumPoolSize）时，执行拒绝策略</li>
<li><strong>PriorityBlockingQueue 具有优先级的无界阻塞队列</strong>，优先级通过参数Comparator实现</li>
</ol>
<h3 id="多线程并发和锁"><a href="#多线程并发和锁" class="headerlink" title="多线程并发和锁"></a>多线程并发和锁</h3><h4 id="线程B怎么知道线程A修改了变量"><a href="#线程B怎么知道线程A修改了变量" class="headerlink" title="线程B怎么知道线程A修改了变量"></a>线程B怎么知道线程A修改了变量</h4><ol>
<li>volatile修饰变量</li>
<li>synchronized修饰修改变量的方法</li>
<li>wait/notify</li>
<li>while轮询</li>
</ol>
<h4 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a>如何创建线程？</h4><ol>
<li>继承Thread类：重写Thread类的run()方法，将创建的线程要执行的代码放在run()方法中，然后创建实例并调用start()启动线程。</li>
<li>实现Runnable接口：重新Runnable接口的run()。创建实例，并将实例作为Thread的参数创建Thread对象，该Thread对象是真正的线程对象。</li>
<li>实现Callable和Future接口，重写Callable接口的call()，可以有返回值,返回值通过FutureTask进行封装。创建实例，将实例作为Thread参数。</li>
<li>使用ExecutorService线程池或者自定义线程池ThreadPoolExecutor;</li>
<li>使用CompletableFuture类执行异步任务。</li>
</ol>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>进程是计算机中正在运行的一个程序实例，比如打开微信；进程是轻量级的进程，多个线程可以在一个进程中同时执行，并且共享进程的资源。</p>
<p>区别：1. 进程是资源分配的基本单位，线程是资源调度和执行的基本单位；2. 进程是相互独立的，每个进程都有独立的内存空间和系统资源，线程共享父进程的所有资源；3. 线程之间的切换开销小，不利于资源的管理和保护，进程相反；</p>
<h4 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h4><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h4 id="什么是线程调度器-Thread-Scheduler-和时间分片-TimeSlicing"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-TimeSlicing" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)?"></a>什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)?</h4><p><strong>线程调度器是一个操作系统服务</strong>，它负责为Runnable 状态的线程分配CPU时间。一旦我们创建一一个线程并启动它，它的执行便依赖于线程调度器的实现。<br><strong>时间分片是指将可用的CPU 时间分配给可用的Runnable线程的过程</strong>。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择(也就是说不要让你的程序依赖于线程的优先级)。</p>
<h4 id="进程间通信方式有哪些？"><a href="#进程间通信方式有哪些？" class="headerlink" title="进程间通信方式有哪些？"></a>进程间通信方式有哪些？</h4><ul>
<li>管道：半双工的通信方式，允许一个进程写入数据到管道，同时另一个进程从管道中读取数据</li>
<li>消息队列：通过消息缓冲区来进行通信的机制。</li>
<li>共享内存：多个进程可以将同一块内存映射到它们的地址内存中，实现共享内存。</li>
<li>信号量Semaphores：是一种用于进程同步和互斥的通信方式。通过信号量，进程可以对资源加锁和解锁。</li>
<li>套接字Socket：进程可以在不同主机或同一主机上的不同进程之间通信。</li>
<li>文件映射：进程可以通过将文件映射到它们的地址空间来共享数据。</li>
</ul>
<h4 id="什么是自旋？"><a href="#什么是自旋？" class="headerlink" title="什么是自旋？"></a>什么是自旋？</h4><p>很多synchronized里面的代码只是一些很简单的代码， 执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为<strong>线程阻塞涉及用户态和内核态切换的问题。</strong>既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h4 id="线程类的构造方法、静态块是被哪个线程调用的？"><a href="#线程类的构造方法、静态块是被哪个线程调用的？" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的？"></a>线程类的构造方法、静态块是被哪个线程调用的？</h4><p>请记住：<strong>线程类的构造方法、 静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的</strong>。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1,<br>main函数中new了Thread2，那么：</p>
<ol>
<li>Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的。</li>
<li>Thread1的构造方法、静态块Thread2调用的，Thread1的run()方法是Thread1自己调用的。</li>
</ol>
<h4 id="多线程同步和互斥有几种实现方法，都是什么"><a href="#多线程同步和互斥有几种实现方法，都是什么" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么?"></a>多线程同步和互斥有几种实现方法，都是什么?</h4><ul>
<li><strong>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息</strong>，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</li>
<li><strong>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排他性。</strong>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用 ，其他要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成一种特殊的线程同步。</li>
</ul>
<p>线程间的同步方法大体可分为两类：<strong>用户模式和内核模式</strong>。 顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<strong>原子操作(例如一个单一的全局变量)，临界区</strong>。 内核模式下的方法有：<strong>事件，信号量，互斥量。</strong></p>
<h4 id="为什么ConcurrentHashMap中key不允许为null"><a href="#为什么ConcurrentHashMap中key不允许为null" class="headerlink" title="为什么ConcurrentHashMap中key不允许为null"></a>为什么ConcurrentHashMap中key不允许为null</h4><p>简单来说，就是为了<strong>避免在多线程环境下出现歧义问题</strong>。所谓歧义问题，就是如果key或者value为null，当我们通过get(key)获取对应的value的时候，如果返回的结果是null。我们没办法判断，它是put(k,v)的时候，value 本身为null值，还是这个key本身就不存在。</p>
<h4 id="ConcurrentHashMap-是怎么保证线程安全的"><a href="#ConcurrentHashMap-是怎么保证线程安全的" class="headerlink" title="ConcurrentHashMap 是怎么保证线程安全的"></a>ConcurrentHashMap 是怎么保证线程安全的</h4><ul>
<li>储存的map数据的数组被volatile关键字修饰。</li>
<li>put时，如果计算出来的数组下标索引没有值，采用无限for循环+CAS算法保证添加成功。</li>
<li>如果put的节点在扩容，会等待扩容，然后进行put操作。</li>
<li>对数据的槽点进行操作，会锁住槽点，保证当前线程对槽点上的链表和红黑树操作。</li>
<li>红黑树旋转时，会锁住根节点，保证旋转时的线程安全。</li>
</ul>
<h4 id="CopyOnWriteArrayList-是怎么保证线程安全的。"><a href="#CopyOnWriteArrayList-是怎么保证线程安全的。" class="headerlink" title="CopyOnWriteArrayList 是怎么保证线程安全的。"></a>CopyOnWriteArrayList 是怎么保证线程安全的。</h4><ul>
<li>数组容器被volatile关键字修饰。</li>
<li>对数组的所有修改操作，都进行了加锁。</li>
<li>修改时对原数组进行了复制。</li>
</ul>
<h4 id="fail-safe-机制与-fail-fast-机制分别有什么作用"><a href="#fail-safe-机制与-fail-fast-机制分别有什么作用" class="headerlink" title="fail-safe 机制与 fail-fast 机制分别有什么作用"></a>fail-safe 机制与 fail-fast 机制分别有什么作用</h4><p>fail-safe 和 fail-fast ，是<strong>多线程并发操作集合时的一种失败处理机制</strong>。</p>
<p>Fail-fast ：表示<strong>快速失败</strong>，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException 异常，从而导致遍历失败。java.util 包下的集合类都是快速失败机制的， 常见的使用 fail-fast 方式遍历的容器有 HashMap 和ArrayList 等。</p>
<p>Fail-safe，表示<strong>失败安全</strong>，也就是在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException。原因是采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所做的修改并不能被迭代器检测到。java.util.concurrent 包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。有 ConcerrentHashMap 和 CopyOnWriteArrayList 等。</p>
<h4 id="lock和synchronized区别？"><a href="#lock和synchronized区别？" class="headerlink" title="lock和synchronized区别？"></a>lock和synchronized区别？</h4><ol>
<li>从<strong>功能角度</strong>来看，Lock 和 Synchronized 都是 Java 中用来解决线程安全问题的工具。</li>
<li>从特性来看，（a）Synchronized 是 Java 中的同步关键字，Lock 是 J.U.C 包中提供的接口，这个接口有很多实现类，其中就包括 ReentrantLock 重入锁。（b）Synchronized 可以通过两种方式来控制锁的粒度，一种是把 synchronized 关键字<strong>修饰在方法层面，另一种是修饰在代码块上</strong>，并且我们可以通过 Synchronized 加锁对象的生命周期来控制锁的作用范围；Lock 锁的粒度是通过它里面提供的 <strong>lock()和 unlock()方法</strong>决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期。</li>
<li>Lock 提供了公平锁和非公平锁的机制。Synchronized 只提供了一种非公平锁的实现。</li>
<li>性能方面来看，Synchronized 引入了偏向锁、轻量级锁、重量级锁以及锁升级的方式来优化加锁的性能，而 Lock中则用到了自旋锁的方式来实现性能优化。</li>
</ol>
<h4 id="wait-和-notify-这个为什么要在-synchronized-代码块中？"><a href="#wait-和-notify-这个为什么要在-synchronized-代码块中？" class="headerlink" title="wait 和 notify 这个为什么要在 synchronized 代码块中？"></a>wait 和 notify 这个为什么要在 synchronized 代码块中？</h4><p>wait 和 notify 用来实现多线程之间的协调，wait 表示让线程进入阻塞状态，notify 表示让阻塞的线程唤醒。wait 和 notify 必然是成对出现的，如果一个线程被 wait(）方法阻塞，那么必然需要另外一个线程通过 notify(）方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。</p>
<p>synchronized同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p>
<h4 id="你是怎么理解线程安全问题？"><a href="#你是怎么理解线程安全问题？" class="headerlink" title="你是怎么理解线程安全问题？"></a>你是怎么理解线程安全问题？</h4><p>线程安全问题的具体表现在三个方面，<strong>原子性、有序性、可见性</strong>。</p>
<ul>
<li>原子性，是指当一个线程执行一系列程序指令操作的时候，它应该是不可中断的，因为一旦出现中断，站在多线程的视角来看，这一系列的程序指令会出现前后执行结果不一致的问题。<strong>CPU 的上下文切换</strong>，是导致原子性问题的核心，而 JVM 里面提供了 Synchronized 关键字来解决原子性问题。</li>
<li>可见性，就是说在多线程环境下，由于读和写是发生在不同的线程里面，有可能出现某个线程对共享变量的修改，对其他线程不是实时可见的。</li>
<li>有序性，指的是程序编写的指令顺序和最终 CPU 运行的指令顺序可能出现不一致的现象，这种现象也可以称为指令重排序，所以有序性也会导致可见性问题。</li>
</ul>
<p>可见性和有序性可以通过 JVM 里面提供了一个 Volatile关键字来解决。</p>
<h4 id="什么是守护线程，它有什么特点"><a href="#什么是守护线程，它有什么特点" class="headerlink" title="什么是守护线程，它有什么特点"></a>什么是守护线程，它有什么特点</h4><p>守护线程就是一种后台服务线程，他和我们在 Java 里面创建的用户线程是一模一样的。</p>
<ol>
<li>在线程创建方面，对于守护线程，我们需要主动调用 setDaemon(）并且设置成 true。</li>
<li>一个 Java 进程中，只要有任何一个用户线程还在运行，那么这个 java 进程就不会结束，否则，这个程序才会终止。</li>
</ol>
<p>Java 进程的终止与否，只和用户线程有关。如果当前还有守护线程正在运行，也不会阻止 Java程序的终止。因此，守护线程的生命周期依赖于用户线程。</p>
<h4 id="请说一下-ReentrantLock-的实现原理？"><a href="#请说一下-ReentrantLock-的实现原理？" class="headerlink" title="请说一下 ReentrantLock 的实现原理？"></a>请说一下 ReentrantLock 的实现原理？</h4><p>ReentrantLock 是一种可重入的排他锁，主要用来解决多线程对共享资源竞争的问题。</p>
<ol>
<li>支持可重入，也就是获得锁的线程在释放锁之前再次去竞争同一把锁的时候，不需要加锁就可以直接访问。</li>
<li>支持公平和非公平特性</li>
<li>提供了阻塞竞争锁和非阻塞竞争锁的两种方法，分别是 lock(）和 tryLock()。</li>
</ol>
<p>ReentrantLock 的底层实现有几个非常关键的技术。</p>
<ol>
<li><p>锁的竞争，ReentrantLock 是通过互斥变量，使用 CAS 机制来实现的。</p>
</li>
<li><p>没有竞争到锁的线程，使用了 AbstractQueuedSynchronizer 这样一个队列同步器来存储，底层是通过双向链表来实现的。当锁被释放之后，会从 AQS 队列里面的头部唤醒下一个等待锁的线程。</p>
</li>
<li><p>公平和非公平的特性，主要是体现在竞争锁的时候，是否需要判断 AQS 队列存在等待中的线程。</p>
</li>
<li><p>关于锁的重入特性，在 AQS 里面有一个成员变量来保存当前获得锁的线程，当同一个线程下次再来竞争锁的时候，就不会去走锁竞争的逻辑，而是直接增加重入次数。</p>
</li>
</ol>
<h4 id="ConcurrentHashMap-的-size-）方法是线程安全的吗？"><a href="#ConcurrentHashMap-的-size-）方法是线程安全的吗？" class="headerlink" title="ConcurrentHashMap 的 size(）方法是线程安全的吗？"></a>ConcurrentHashMap 的 size(）方法是线程安全的吗？</h4><p>ConcurrentHashMap 的 size(）方法是<strong>非线程安全的</strong>。也就是说，当有线程调用 put 方法在添加元素的时候，其他线程在调用 size(）方法获取的元素个数和实际存储元素个数是不一致的。</p>
<p>原因是 size(）方法是一个非同步方法，put(）方法和 size(）方法并没有实现同步锁。put(）方法的实现逻辑是：<strong>在 hash 表上添加或者修改某个元素，然后再对总的元素个数进行累加</strong>。其中，线程的安全性仅仅局限在 hash 表数组粒度的锁同步，避免同一个节点出现数据竞争带来线程安全问题。</p>
<p>size(）方法的逻辑就是遍历 CounterCell 数组中的每个 value 值进行累加，再加上 baseCount，汇总得到一个结果。所以很明显，size(）方法得到的数据和真实数据必然是不一致的。因此从 size(）方法本身来看，它的整个计算过程是线程安全的，因为这里用到了 CAS 的方式解决了并发更新问题。</p>
<p>但是站在 ConcurrentHashMap 全局角度来看，put(）方法和 size(）方法之间的数据是不一致的，因此也就不是线程安全的</p>
<h4 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别?"></a>synchronized和Lock有什么区别?</h4><ul>
<li>语法层面：synchronized是关键字，源码在jym中，用C++语言实现<br>Lock是接口，源码由jdk提供，用java语言实现<br><strong>使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁</strong></li>
<li>功能层面：二者均属于<strong>悲观锁</strong>、都具备基本的互斥、同步、锁重入功能<br>Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量<br>Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock(读写锁)</li>
<li>性能层面：<br>在没有竞争时，synchronized 做了很多优化，如<strong>偏向锁、轻量级锁</strong>，性能不赖<br>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
<h4 id="Synchronized的锁升级过程"><a href="#Synchronized的锁升级过程" class="headerlink" title="Synchronized的锁升级过程?"></a>Synchronized的锁升级过程?</h4><p>synchronized是Java中的关键字，是一种同步锁，主要应用于多线程环境下保证线程的安全性。其锁升级过程主要包括以下几个阶段：</p>
<ol>
<li><strong>偏向锁</strong>：偏向锁的目的是尽可能减少无竞争情况下的同步操作开销。当一个线程访问同步块并获取对象的锁时，会将锁的标记记录在线程的栈帧中，并将对象头中的Thread ID设置为当前线程的ID。</li>
<li><strong>轻量级锁（自旋锁）</strong>：如果偏向锁失败，那么会尝试轻量级锁。一个或多个线程通过CAS（Compare and Set）去争抢锁，如果抢不到则一直自旋。如果CAS成功，则表示线程获取了轻量级锁，并继续执行同步块。如果CAS失败，说明有竞争，虚拟机会通过自旋等待其他线程释放锁。</li>
<li><strong>重量级锁</strong>：如果自旋等待不成功，虚拟机会将轻量级锁升级为重量级锁。在这种状态下，虚拟机会将线程阻塞，并使用操作系统的互斥量来实现锁的释放和获取。重量级锁将未获得锁的线程阻塞，不消耗CPU，防止CPU空运行。</li>
</ol>
<p>额外知识：synchonized：当线程执行到monitorenter的时候要先获得锁，才能执行后面的方法；当线程执行到monitorexit的时候则要释放锁。</p>
<h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>Compare and Swap，是一种用于实现并发控制的原子操作，常用于多线程环境下对共享数据进行操作时的同步。CAS算法的核心思想是通过比较内存中的值和预期值，如果相等则将新值写入内存，否则不做任何操作。这种原子性操作可以确保在多线程环境下对共享数据的安全访问，避免了传统锁机制中的死锁和线程阻塞等问题。</p>
<p>缺点：<strong>ABA问题（版本号），循环开销</strong>（自旋）</p>
<h4 id="Synchronized是公平锁吗？ReentrantLock是怎么实现公平锁的？"><a href="#Synchronized是公平锁吗？ReentrantLock是怎么实现公平锁的？" class="headerlink" title="Synchronized是公平锁吗？ReentrantLock是怎么实现公平锁的？"></a>Synchronized是公平锁吗？ReentrantLock是怎么实现公平锁的？</h4><p><code>synchronized</code> 关键字在 Java 中提供的锁并不是公平锁。公平锁意味着等待时间最长的线程将优先获得锁，而非公平锁则不保证等待顺序，任何尝试获取锁的线程都有机会立即获取到锁，这可能导致某些线程长时间得不到执行。<code>synchronized</code> 的非公平锁策略可以减少线程切换的开销，从而提高吞吐量。</p>
<p><code>ReentrantLock</code> 实现公平锁的主要方式是通过维护一个等待队列（通常是 FIFO 队列）。当线程请求锁时，如果锁被其他线程持有，那么请求锁的线程会被加入到等待队列中。当持有锁的线程释放锁时，等待队列中的第一个线程（即等待时间最长的线程）会被唤醒并尝试获取锁。这样就保证了等待时间最长的线程会优先获得锁，从而实现了公平锁。</p>
<h4 id="volatile是如何保证可见性和有序性的？"><a href="#volatile是如何保证可见性和有序性的？" class="headerlink" title="volatile是如何保证可见性和有序性的？"></a>volatile是如何保证可见性和有序性的？</h4><p><strong>可见性</strong>：对volatile变量进行写操作时，JVM会向处理器发送一条lock前缀的指令，将缓存中变量写回系统主存中。</p>
<p><strong>有序性</strong>：volatile是通过<strong>内存屏障</strong>来禁止指令重排的，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt; add-&gt;save的执行顺序就是: load、add、save。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="谈谈你对-AQS-的理解"><a href="#谈谈你对-AQS-的理解" class="headerlink" title="谈谈你对 AQS 的理解"></a>谈谈你对 AQS 的理解</h4><p>AQS 是 AbstractQueuedSynchronizer 的简称，是并发编程中比较核心的组件。<br>AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、CountDownLatch、Semaphore等都用到了 AQS.<br>从本质上来说，AQS 提供了两种锁机制，分别是排他锁，和共享锁。</p>
<p><strong>排它锁</strong>，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重入锁实现就是用到了 AQS 中的排它锁功能。</p>
<p><strong>共享锁也称为读锁</strong>，就是在同一时刻允许多个线程同时获得锁资源，比如 CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。</p>
<ul>
<li>AQS是一个框架锁，定义了锁的实现机制，并开放出扩展的地方，让子类实现。AQS开放了state字段，子类可以依据state字段决定能否获得锁。</li>
<li>AQS底层是同步队列+条件队列组成，同步管理着锁的线程排队和释放，条件队列是在一定条件下对同步队列的补充。</li>
<li>AQS围绕着两个队列，提供了四大场景，分别是：获得锁，释放锁，条件队列的堵塞，条件队列的唤醒。</li>
</ul>
<h4 id="AQS-核心思想"><a href="#AQS-核心思想" class="headerlink" title="AQS 核心思想"></a>AQS 核心思想</h4><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。</p>
<p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p>AQS 使用 int 成员变量 <code>state</code> 表示同步状态，通过内置的 <code>FIFO</code> 线程等待/等待队列 来完成获取资源线程的排队工作。</p>
<h4 id="AQS-资源共享方式"><a href="#AQS-资源共享方式" class="headerlink" title="AQS 资源共享方式"></a>AQS 资源共享方式</h4><p>AQS 定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如<code>Semaphore</code>/<code>CountDownLatch</code>）。</p>
<p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h4 id="常见同步工具类"><a href="#常见同步工具类" class="headerlink" title="常见同步工具类"></a>常见同步工具类</h4><ul>
<li><p>**Semaphore(信号量)**：<code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。<code>Semaphore</code> 有两种模式：1.公平模式遵循FIFO；2.非公平锁模式。</p>
</li>
<li><p><strong>CountDownLatch （倒计时器）</strong>：是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>count</code><br><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。<br><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
</li>
<li><p><strong>CyclicBarrier(循环栅栏)</strong><br><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<br><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
</li>
</ul>
<h4 id="多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"><a href="#多个线程通过锁请求共享资源，获取不到锁的线程怎么办？" class="headerlink" title="多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"></a>多个线程通过锁请求共享资源，获取不到锁的线程怎么办？</h4><p>加锁（排他锁）的步骤分为四步：</p>
<ol>
<li>能获得锁直接返回，不能获得继续</li>
<li>用Node封装当前的线程，追加到同步队列的队尾，有如下两步</li>
<li>自旋+CAS保证前一个节点为signal</li>
<li>阻塞自己，使当前线程进入等待状态</li>
</ol>
<h4 id="排他锁和共享锁的处理机制是一样的么？"><a href="#排他锁和共享锁的处理机制是一样的么？" class="headerlink" title="排他锁和共享锁的处理机制是一样的么？"></a>排他锁和共享锁的处理机制是一样的么？</h4><p>上述2,3,4步骤是一致的，但是第一步中，线程获得排他锁的时候，仅仅把自己设置为同步队列的头节点，但如果是共享锁，还会唤醒自己的后续节点一起获得这个锁。</p>
<h4 id="描述一下线程入、出同步队列的时机和过程？"><a href="#描述一下线程入、出同步队列的时机和过程？" class="headerlink" title="描述一下线程入、出同步队列的时机和过程？"></a>描述一下线程入、出同步队列的时机和过程？</h4><p>同步队列入队时机：1.多个线程请求锁，获取不到锁的线程需要到同步队列中排队阻塞；2.条件队列中的节点被唤醒，会从条件队列中转移到同步队列中来。</p>
<p>同步队列出队时机：1.锁释放时，头节点出队；2.获得锁的线程，进入条件队列时，会释放锁，同步队列头节点开始竞争锁。</p>
<h4 id="描述一下条件队列的元素入队和出队的时机和过程？"><a href="#描述一下条件队列的元素入队和出队的时机和过程？" class="headerlink" title="描述一下条件队列的元素入队和出队的时机和过程？"></a>描述一下条件队列的元素入队和出队的时机和过程？</h4><p>入队时机：执行await方法时，当前线程会释放锁，并进入到条件队列。</p>
<p>出队时机：执行signal、signalAll方法时，节点会从条件队列中移到同步队列。</p>
<h4 id="什么是可重入锁，怎么实现可重入锁？"><a href="#什么是可重入锁，怎么实现可重入锁？" class="headerlink" title="什么是可重入锁，怎么实现可重入锁？"></a>什么是可重入锁，怎么实现可重入锁？</h4><p>可重入锁是一种多线程同步机制，允许同一线程多次获取同一个锁而不会导致死锁。这意味着一个线程可以在持有锁的情况下再次请求并获得相同的锁，不会被自己阻塞。可重入锁有助于避免死锁和提高代码的可维护性,因为允许在一个线程中嵌套地调用锁定的方法。</p>
<p>如我们常用的synchronized和reentrantLock都是比较典型的可重入锁。也就是说，在一个线程调用synchronized方法的同时，可以在方法体内部调用该对象另一个synchronized方法， 也就是说一个线程得到一个对象锁后再次请求该对象锁。</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="解释内存中的栈-stack-、-堆-heap-和方法区-method-area-的用法"><a href="#解释内存中的栈-stack-、-堆-heap-和方法区-method-area-的用法" class="headerlink" title="解释内存中的栈(stack)、 堆(heap) 和方法区(method area)的用法"></a>解释内存中的栈(stack)、 堆(heap) 和方法区(method area)的用法</h4><ul>
<li>一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的<strong>栈空间</strong>；</li>
<li>而通过new关键字和构造器创建的对象则放在<strong>堆空间</strong>，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor( 又可分为 From Survivor和To Survivor ). </li>
<li><strong>方法区和堆</strong>都是各个线程共享的内存区域 ，用于存储已经被JVM加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；</li>
<li>程序中的字面量(literal) 如直接书写的100、 hello和常量都是放在常量池中 ，<strong>常量池是方法区的一部分</strong>。栈空间操作起来最快但是栈很小， 通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整。</li>
</ul>
<h4 id="一个空的Object对象占多大空间？"><a href="#一个空的Object对象占多大空间？" class="headerlink" title="一个空的Object对象占多大空间？"></a>一个空的Object对象占多大空间？</h4><p>在开启了压缩指针的情况下，Object默认会占用12个字节，但是为了<strong>避免伪共享问题</strong>，JVM 会按照8个字节的倍数进行填充，所以会填充4个字节变成16个字节长度。<br>在关闭压缩指针的情况下，Object 默认会占用16个字节，16个字节正好是8的整数倍，因此不需要填充。</p>
<p><img src="/2024/05/20/mian-shi-zheng-li/image-20240522173220554.png">因此，一个空的对象，在开启压缩指针的情况下，占16个字节。其中Markword占8个字节、类元指针占4个字节，对齐填充占 4个字节。</p>
<h4 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h4><ul>
<li>强引用，就是普通对象的引用，只要还有强引用指向一个对象，就能表示对象还“活着”，垃圾收集器无法回收这一类对象。</li>
<li>软引用，是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>弱引用，相对强引用而言，它允许在存在引用关联的情况下被垃圾回收的对象在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有<strong>弱引用</strong>的对象，不管当前<strong>内存空间足够与否</strong>，垃圾回收器都会<strong>回收</strong>该内存</li>
<li>虚引用，它不会决定对象的生命周期，它提供了一种确保对象被 finalize 以后，去做某些事情的机制。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入与之关联的引用队列中。程序可以通过判断引用<strong>队列</strong>中是否已经加入了<strong>虚引用</strong>，来了解被引用的对象是否将要进行<strong>垃圾回收</strong>，然后我们就可以在引用的对象的内存回收之前采取必要的行动。</li>
</ul>
<h4 id="JVM-为什么使用元空间替换了永久代？"><a href="#JVM-为什么使用元空间替换了永久代？" class="headerlink" title="JVM 为什么使用元空间替换了永久代？"></a>JVM 为什么使用元空间替换了永久代？</h4><p><strong>元空间不属于 JVM 内存，而是直接使用本地内存，因此不需要考虑 GC 问题</strong>。</p>
<ul>
<li>在 1.7 版本里面，永久内存是有上限的，虽然我们可以通过参数来设置，但是 JVM 加载的 class 总数、大小是很难确定的。所以很容易出现 OOM 问题。但是元空间是存储在本地内存里面，内存上限比较大，可以很好地避免这个问题。</li>
<li>永久代的对象是通过 FullGC 进行垃圾收集，也就是和老年代同时实现垃圾收集。替换成元空间以后，简化了 Full GC。可以在不进行暂停的情况下并发地释放类数据，同时也提升了 GC 的性能</li>
<li>Oracle 要合并 Hotspot 和 JRockit 的代码，而 JRockit 没有永久代表。</li>
</ul>
<h4 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h4><ol>
<li>集成 ClassLoader 抽象类，重写 loadClass 方法，在这个方法可以自定义要加载的类使用的类加载器</li>
<li>使用线程上下文加载器，可以通过 java.lang.Thread 类的 setContextClassLoader(）方法来设置当前类使用的类加载器类型。</li>
</ol>
<h4 id="怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>怎么获取 Java 程序使用的内存？堆使用的百分比？</h4><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数 ， Runtime.total Memory() 方法总内 存的字节数 ， Runtime.maxMemory() 返回最大内存的字节数。</p>
<h4 id="内存泄漏和内存溢出的区别是什么？"><a href="#内存泄漏和内存溢出的区别是什么？" class="headerlink" title="内存泄漏和内存溢出的区别是什么？"></a>内存泄漏和内存溢出的区别是什么？</h4><p><strong>内存泄漏指的是程序中分配的内存在不再需要时没有被正确释放或回收的情况。</strong>这会导致程续占用内存,随着时间的推移,可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</p>
<p><strong>内存溢出指的是程序试图分配超过其可用内存的内存空间的情况</strong>。这通常会直接导致Java程序崩溃。</p>
<h4 id="运行时常量池VS常量池"><a href="#运行时常量池VS常量池" class="headerlink" title="运行时常量池VS常量池"></a>运行时常量池VS常量池</h4><p>常量池：字节码文件内部，看作是一张表，用于存放编译期生成的各种字面量与符号引用（直接引用在方法区找到），虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<p>运行时常量池：具备动态性，在方法区内部，常量池在类加载后（符号引用对应的直接引用）存放到运行时常量池<br><strong>动态链接</strong>：运行时常量池支持方法和字段的动态链接，这允许在类加载阶段或运行时解析对其他类的方法和字段的引用。这种方法提高了程序的灵活性，使得类的加载顺序不再严格受限，有助于实现类的按需加载。</p>
<h4 id="Java中的类什么时候会被加载？"><a href="#Java中的类什么时候会被加载？" class="headerlink" title="Java中的类什么时候会被加载？"></a>Java中的类什么时候会被加载？</h4><ol>
<li>当创建类的实例时，如果该类还没有被加载，则会触发类的加载。</li>
<li>当使用类的静态变量或静态方法时，如果该类还没有被加载，则会触发类的加载。</li>
<li>当使用反射机制访问类时，如果该类还没有被加载，则会触发类的加载。</li>
<li>当JVM启动时，自动加载一些基础类，例如java.lang.Object类和java.lang.Class类等。</li>
</ol>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ul>
<li><strong>加载</strong>：将字节码从不同的元数据转化为二进制字节流存到方法区（永久代或者元空间）中，并在堆中生成一个Class对象，Class对象存储类型信息 （<strong>类信息、字段信息、方法信息、常量</strong>）<strong>等数据</strong>，这些类型信息就存放在方法区中</li>
<li><strong>连接</strong>：1.验证：校验类的正确性；2.准备：为类变量分配内存并设置类变量的默认初始值。3.解析：把类的符号引用转为直接引用。</li>
<li><strong>初始化</strong>：执行类构造器clinit()方法，合并静态变量赋值语句和静态代码块</li>
</ul>
<h4 id="JVM是如何创建对象的？"><a href="#JVM是如何创建对象的？" class="headerlink" title="JVM是如何创建对象的？"></a>JVM是如何创建对象的？</h4><ol>
<li>首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，检查这个符号引用代表的类是否配被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</li>
<li>分配内存。JVM会在堆中为对象分配内存空间。在HotSpot中，对象的内存分配有两种方式，分别是指针碰撞和空闲列表法。<strong>指针碰撞</strong>：当堆中的内存是连续的，JVM使用一个指针来标记当前可用的内存位置，然后将指针向前移动分配对象所需的内存大小。<strong>空闲列表：</strong>当堆中的内存是离散的，JVM会维护一个空闲列表，记录可用的内存块。在分配对象时，JVM会遍历空闲列表，找到足够大小的内存块进行分配。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步确保了对象的字段在创建时都有默认值。如int被初始化为0，引用类型被初始化为null</li>
<li>设置对象头。该实例所对应的类如何才能我到类的元数据信息、对象的哈希码、对象的GC分代年龄,轻量级锁等等信息</li>
<li>调用该类的构造方法，初始化对象。</li>
<li>返回对象引用，当对象完成创建之后，返回一个该对象的引用，后续Java程序就可以使用这个引用来操作对象了。</li>
</ol>
<h4 id="YoungGC和FullGC的触发条件是什么？"><a href="#YoungGC和FullGC的触发条件是什么？" class="headerlink" title="YoungGC和FullGC的触发条件是什么？"></a>YoungGC和FullGC的触发条件是什么？</h4><p>YoungGC的触发条件非常简单，只是年轻代中Eden区满了就触发。</p>
<p>FullGC触发条件：1.老年代的空间不足。2.永久代空间不足。3.代码中执行System.gc()。</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>新生代收集器有Serial、ParNew、 Parallel Scavenge（关注点是吞吐量，高效率的利用CPU）。</p>
<p>老年代收集器有Serial Old、Parallel Old。</p>
<p>CMS：一种获取最短回收停顿时间为目标的收集器，并发收集器。标记-清除：1.初始标记；2.并发标记；3.重新标记；4.并发清除。</p>
<p>G1收集器：面向服务器，正针对多颗处理器和大容量内存的机器，满足GC停顿时间要求的同时，具备高吞吐量。</p>
<p>ZGC收集器：采用标记-复制。牺牲了吞吐量，获得Stop the world的情况更少。</p>
<h4 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h4><ol>
<li>堆设置：-Xms：设置堆的初始大小。-Xmx：设置堆的最大大小。</li>
<li>栈设置：-Xss：设置每个线程的栈大小。</li>
<li>垃圾回收器设置：-XX:+UseG1GC：使用G1垃圾回收器</li>
<li>性能调优：-XX:PerSize和-XX:MaxPermSize：java8之前设置永久带的初始大小和最大大小。   -XX:+PrintGCDetails：打印垃圾回收的详细信息</li>
<li>调试和分析：-verbose:gc：输出垃圾回收的详细信息</li>
</ol>
<h4 id="哪些需要进行调优"><a href="#哪些需要进行调优" class="headerlink" title="哪些需要进行调优"></a>哪些需要进行调优</h4><ul>
<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>
<li>Full GC 次数频繁；</li>
<li>GC 停顿时间过长（超过1秒）；</li>
<li>应用出现OutOfMemory 等内存异常；</li>
<li>应用中有使用本地缓存且占用大量内存空间；</li>
<li>系统吞吐量与响应性能不高或下降。</li>
</ul>
<h4 id="JVM调优步骤"><a href="#JVM调优步骤" class="headerlink" title="JVM调优步骤"></a>JVM调优步骤</h4><ul>
<li>分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定JVM调优量化目标；</li>
<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>
<li>依次确定调优内存、延迟、吞吐量等指标；</li>
<li>对比观察调优前后的差异；</li>
<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>
<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>
</ul>
<h4 id="JVM的运行时内存区域是怎样的？"><a href="#JVM的运行时内存区域是怎样的？" class="headerlink" title="JVM的运行时内存区域是怎样的？"></a>JVM的运行时内存区域是怎样的？</h4><p>根据Java虚拟机规范的定义，JVM的运行时内存区域主要由Java堆、虚拟机栈、本地方法栈、方法区和程序计数器以及运行时常量池组成。其中堆、方法区以及运行时常量池是线程之间共享的区域，而栈(本地方法栈+虚拟机栈)、程序计数器都是线程独享的。</p>
<h4 id="Java的堆是如何分代的？为什么分代？"><a href="#Java的堆是如何分代的？为什么分代？" class="headerlink" title="Java的堆是如何分代的？为什么分代？"></a>Java的堆是如何分代的？为什么分代？</h4><p>Java的堆由新生代和老年代组成。新生代存放新分配的对象，老年代存放长期存在的对象。新生代由年轻代Eden和Survivor区组成。15岁到old（4bit）</p>
<p>很多对象都会出现在Eden区，当Eden区的内存容用完的时候，GC会发起，非存活对象会被标记为死亡，存活的对象被移动到Survivor区。如果Survivor的内存容量（form区和to区，每次使用年龄+1，到15岁到old）也用完，那么存活对象会被移动到老年代。</p>
<h4 id="YoungGC和FullGC的触发条件是什么？-1"><a href="#YoungGC和FullGC的触发条件是什么？-1" class="headerlink" title="YoungGC和FullGC的触发条件是什么？"></a>YoungGC和FullGC的触发条件是什么？</h4><p>YoungGC的触发条件非常简单，只是年轻代中Eden区满了就触发。</p>
<p>FullGC触发条件：老年代的空间不足。永久代空间不足。代码中执行System.gc()。</p>
<h4 id="什么是Class常量池，和运行时常量池关系是什么？"><a href="#什么是Class常量池，和运行时常量池关系是什么？" class="headerlink" title="什么是Class常量池，和运行时常量池关系是什么？"></a>什么是Class常量池，和运行时常量池关系是什么？</h4><p>Class常量池可以理解为是Class文件中的资源仓库。Class文件中除了包含类的版本、字段、方法、接口等描述信外，还有一项信息就是常量地(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</p>
<p>Class用来保存常量的一个媒介场所，是一个中间场所。 Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ol>
<li><strong>Jconsole</strong>：查看java进程中线程的运行状态</li>
<li><strong>查看堆内存</strong>：1.jps查看所有java进程；2.找到某个进程的pid，使用jstat -gc pid 查看堆内存分布</li>
<li>使用的垃圾收集器版本：JDK17是G1垃圾收集器；JDK1.8是新生代Parallel Scanvenge 老年代Serial Old组合</li>
</ol>
<h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><h4 id="MySQL的B-树的高度怎么计算"><a href="#MySQL的B-树的高度怎么计算" class="headerlink" title="MySQL的B+树的高度怎么计算?"></a>MySQL的B+树的高度怎么计算?</h4><p>InnoDB存储引擎最小储存单元是页，<strong>一页大小就是16k</strong>。B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表<strong>通过非叶子节点的二分查找法以及指针确定数据在哪个页中</strong>，进而再去数据页中找到需要的数据。</p>
<p>假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数是单个叶子节点记录行数。</p>
<ul>
<li>如果一行记录的数据大小为 1k，那么单个叶子节点可以存的记录数=16k/1k=16.</li>
<li>非叶子节点内存放多少指针呢? 我们假设主键ID为bigint类型，长度为8字节(int类型，一个int就是32位，4字节)，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B =1170</li>
</ul>
<p>因此，一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400数据。</p>
<h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><ul>
<li>1NF(第一范式)：遵循原子性。即，<strong>表中字段的数据，不可以再拆分</strong>。</li>
<li>2NF(第二范式)：<strong>主键关系</strong>，要求数据表中的每个非主键字段完全依赖于主键，而不是依赖于其他非主键字段。可以避免数据冗余和更新异常的问题。</li>
<li>3NF(第二范式)：<strong>外键关系</strong>，每个非主键字段都不依赖于其他非主键字段，而直接依赖于主键。</li>
</ul>
<h4 id="说一下对InnoDB索引数据结构的理解？"><a href="#说一下对InnoDB索引数据结构的理解？" class="headerlink" title="说一下对InnoDB索引数据结构的理解？"></a>说一下对InnoDB索引数据结构的理解？</h4><p>在InnoDB中的数据都是以行的形式存储在page页，并且page页跟page页以双向链表进行关联。在去查询数据的时候，如果**基于链表去查询，由于链表的查询性能是O(n)**，数据越大，查询的性能会越来越慢。<br>InnoDB的实现方式采取了跟书目录一样的思想，为每个page页创建一个目录记录，这些目录记录也都会保存到page页，由于page页大小有限，所以就会有多个目录page。当有多个目录 page的时候，再为目录page创建一个目录，直到根节点。最后形成了一个叶子节点是存有真实数据的page页的双向链表，而非叶子节点是存储目录的page页的树形结构。这样的数据结构我们就称为B+树。</p>
<ul>
<li>树的查询性能比链表要高很多,查询次数由树的高度来决定，树越矮跟磁盘的IO次数也就越低</li>
<li>第二，查询相对稳定，因为数据全部在叶子节点，不管查询什么数据，都需要查询到叶子节点。</li>
</ul>
<p>和其他数据结构比较：</p>
<ol>
<li><strong>二叉树会有斜树的可能，会退化成链表</strong>，那么索引树就没有作用</li>
<li>红黑树，树的高度会很高。</li>
<li>B-树的数据结构虽然跟B+很类似，但是B-没有目录节点，每个节点都存储真实的数据，那样由于每个page要存的数据变大，节点就会越多，树层级就越高，查询来讲整体变慢。</li>
</ol>
<p>所以，InnoDB 索引的目的是<strong>通过空间换时间</strong>，并且尽可能地去减少磁盘的IO次数。这也是为什么用B+树，而不用跳表等其他数据结构的原因。</p>
<h4 id="update是锁行还是锁表"><a href="#update是锁行还是锁表" class="headerlink" title="update是锁行还是锁表"></a>update是锁行还是锁表</h4><p>MySQL的Update操作既可以锁行，也可以锁表,具体使用哪种锁类型，取决于执行的Update语句的条件、事务隔离级别等因素。</p>
<p>如果 update 语句中的 <strong>where 条件包含了索引列，并且只更新一条数据，那这个时候就加行锁</strong>。<strong>如果 where 条件中不包含索引列，这个时候会加表锁</strong>。<br>另外，根据查询范围不同，Mysql也会选择不同粒度的锁来避免幻读问题。<br>比如针对主键索引的 for update 操作：SELECT * FROM t WHERE id = 10 FOR UPDATE；<br>Mysql 会增加 Next-Key Lock 来锁定id=10 索引所在的区间<br>另外，针对索引区间的查询或者修改SELECT * FROM user WHERE id BETWEEN 1 AND 100 FOR UPDATE；<strong>Mysql会自动对索引间隙加锁，来解决幻读问题。</strong></p>
<h4 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h4><ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ol>
<h4 id="说一下你对行锁、临键锁、间隙锁的理解"><a href="#说一下你对行锁、临键锁、间隙锁的理解" class="headerlink" title="说一下你对行锁、临键锁、间隙锁的理解"></a>说一下你对行锁、临键锁、间隙锁的理解</h4><p>行锁、临键锁、间隙锁，都是 Mysql 里面 InnoDB 引擎下解决事务隔离性的一系列<strong>排他锁</strong>。</p>
<ul>
<li><strong>行锁，也称为记录锁</strong>。当我们针对主键或者唯一索引加锁的时候，Mysql 默认会对查询的这一行数据加行锁，避免其他事务对这一行数据进行修改。</li>
<li>间隙锁，顾名思义，就是<strong>锁定一个索引区间</strong>。在普通索引或者唯一索引列上，由于索引是基于 B+树的结构存储，所以默认会存在一个索引区间。而间隙锁，就是某个事物对索引列加锁的时候，默认锁定对应索引的左右开区间范围。</li>
<li>临键锁，它相当于<strong>行锁+间隙锁的组合</strong>，也就是它的锁定范围既包含了索引记录，也包含了索引区间。它会锁定一个左开右闭区间的数据范围。</li>
</ul>
<p>行锁、临键锁、间隙锁只是表示锁定数据的范围，最终目的是解决幻读的问题。而临键锁相当于行锁+间隙锁，因此当我们使用非唯一索引进行精准匹配的时候，会默认如临键锁，因为它需要锁定匹配的这一行数据，还需要锁定这一行数据对应的左开右闭区间。</p>
<h4 id="Select语句完整的执行顺序"><a href="#Select语句完整的执行顺序" class="headerlink" title="Select语句完整的执行顺序"></a>Select语句完整的执行顺序</h4><ol>
<li>from 子句组装来自不同数据源的数据；</li>
<li>where 子句基于指定的条件对记录行进行筛选；</li>
<li>group by 子句将数据划分为多个分组；</li>
<li>使用聚集函数进行计算；</li>
<li>使用 having 子句筛选分组；</li>
<li>计算所有的表达式；</li>
<li>select 的字段；</li>
<li>使用 order by 对结果集进行排序。</li>
</ol>
<h4 id="select语句的具体执行过程"><a href="#select语句的具体执行过程" class="headerlink" title="select语句的具体执行过程"></a>select语句的具体执行过程</h4><ul>
<li>先和数据库建立连接，接着查询中的缓存看有没有命中，key是查询语句，value是查询结果</li>
<li>解析sql：执行此法分析和语法分析，识别关键词，判断sql语句是否满足mysql语法，形成语法树。方便后续的查询</li>
<li>执行sql：<br>1.预处理阶段：检查 SQL 查询语句中的表或者字段是否存在，将 select * 中的 * 符号，扩展为表上的所有列<br>2.优化阶段：确定SQL查询语句具体执行方案，降低查询的成本，比如走哪个索引<br>3.运行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。有哪些执行计划呢，比如全表扫描，使用主键索引，使用唯一索引等等</li>
</ul>
<h4 id="update语句的具体执行过程"><a href="#update语句的具体执行过程" class="headerlink" title="update语句的具体执行过程"></a>update语句的具体执行过程</h4><p>以update t_user SET name=’xiaoma’ WHERE id = 1为例</p>
<ol>
<li>执行器负责执行，通过主键索引搜索获取id=1这一行记录：（1）如果记录在buffer pool中，直接返回执行器更新。（2）如果不在，将数据页从磁盘中读入buffer pool，返回记录。</li>
<li>执行器得到聚簇索引记录后，会看更新一致不一致：（1）一致不更新后续步骤。（2）不一致，把更新前和更新后的数据当作参数传入InnoDB层，让InnoDB执行更新操作。</li>
<li>开启事务，更新记录之前，记录相应的undo log，undo log写入buffer pool中的Undo页面，在内存修改Undo页面后，需要记录对应的redo log。</li>
<li>InnoDB开始更新记录，会将更新内存标记为脏页，将记录写入redo log。更新完成后，不会立即将脏页写入磁盘，而是后续后台线程写入（WAL技术）。</li>
<li>一条指令就更新完毕了。</li>
<li>更新完成后，开始记录对应语句的binlog，记录的binlog会保存到binlog cache，没有直接刷新到binlog文件中。</li>
<li>事物提交（两阶段提交）。1.prepare阶段：将redo log对应事物状态为prepare，然后将redo log刷新到磁盘。2.commit阶段：将binlog刷新到磁盘，将redo log状态为commit（刷入磁盘redo log文件）。</li>
</ol>
<h4 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h4><ol>
<li>读写分离</li>
<li>分段加锁</li>
<li>减少锁持有的时间</li>
<li>多个线 程尽量以 相同的顺 序去获取 资源不能将锁的粒度过于细化 ，不然可能会出现线程的加锁和释放次数过多 ， 反而效率不如一次加一把大锁</li>
</ol>
<h4 id="如何处理慢查询"><a href="#如何处理慢查询" class="headerlink" title="如何处理慢查询"></a>如何处理慢查询</h4><p>1.开启慢查询：慢查询日志记录默认是关闭的，所以开启数据库 mysql 的慢查询记录的功能从慢查询日志中去获取哪些 sql 语句时慢查询，默认 10S，从中获取到 sql 语句进行分析</p>
<p>2.通过 explain 执行 sql，主要关心以下字段</p>
<p><img src="/2024/05/20/mian-shi-zheng-li/20240523133836.png"></p>
<p>Id：执行顺序。如果是关联查询，会据此判断主表、从表。<br>Select_type：simple    Table：表<br>Type：ALL 未创建索引 、const、 常量 ref 其他索引 、eq_ref 主键索引<br>Rows：检索的行数，与查询返回的行数无关，，数值越大越不好，说明没有用好索引<br>extra：该列包含 MySQL 解决查询的详细信息。</p>
<h4 id="谈谈你对MVCC的理解"><a href="#谈谈你对MVCC的理解" class="headerlink" title="谈谈你对MVCC的理解"></a>谈谈你对MVCC的理解</h4><p>MVCC 就是为了解决事务操作中并发安全性问题的无锁并发控制技术全称为 Multi-VersionConcurrency Control ，也就是多版本并发控制。它是通过数据库记录中的<strong>隐式字段，undo 日志 ，Read View</strong>来实现的。</p>
<ul>
<li>隐藏字段：1.trx_id事务id，记录了每一个操作的事务id，自增；2.roll_pointer回滚指针，指向上一个版事务版本记录地址，形成版本链。</li>
<li>undo log：1.回滚日记，存储老版本数据；2.版本链</li>
<li>Readview解决一个事务查询版本的问题。有四个字段：1.事务id列表；2.事务id最小的事物；3.创建readview时当前数据库中应该给下一个事物的id值；4.创建该readview的事务的事务id。</li>
</ul>
<p>MVCC 主要解决了三个问题</p>
<ol>
<li>通过 MVCC 可以解决读写并发阻塞问题从而提升数据并发处理能力</li>
<li>MVCC 采用了乐观锁的方式实现，降低了死锁的概率</li>
<li>解决了一致性读的问题也就是事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化。</li>
</ol>
<h4 id="什么是索引覆盖、索引下推？"><a href="#什么是索引覆盖、索引下推？" class="headerlink" title="什么是索引覆盖、索引下推？"></a>什么是索引覆盖、索引下推？</h4><p>索引(covering index)指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。可以称之为实现了索引覆盖。当一查询语询符合覆盖条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。</p>
<p>索引下推：如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</p>
<h4 id="binlog-有几种格式？分别有什么区别"><a href="#binlog-有几种格式？分别有什么区别" class="headerlink" title="binlog 有几种格式？分别有什么区别"></a>binlog 有几种格式？分别有什么区别</h4><p>Binlog 有三种格式：statement，row 和 mixed</p>
<ul>
<li>statement，记录的是 SQL 的原文。好处是，不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高性能。由于 sql 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row，不记录 sql 语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动（比如 alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折衷的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用row。</li>
</ul>
<h4 id="binlog-和-redolog-有什么区别？"><a href="#binlog-和-redolog-有什么区别？" class="headerlink" title="binlog 和 redolog 有什么区别？"></a>binlog 和 redolog 有什么区别？</h4><p>binlog(二进制日志) 和 redolog 都是 Mysql 里面用来记录数据库数据变更操作的日志。</p>
<ol>
<li>使用场景不同，<strong>binlog 主要用来做数据备份、数据恢复，以及主从集群的数据同步； Redo Log主要用来实现 Mysql 数据库的事务恢复，保证事务的 ACID 特性</strong>。当数据库出现崩溃的时候，RedoLog 可以把未提交的事务回滚，把已提交的事务进行持久化，从而保证数据的一致性和持久性。</li>
<li>记录的信息不同，binlog 是记录数据库的逻辑变化，它提供了三种日志格式分别是 statement，row 以及 mixed；redo log 记录的是物理变化，也就是数据页的变化结果。</li>
<li>记录的时机不同， binlog 是在执行 SQL 语句的时候，在主线程中生成逻辑变化写入到磁盘中，所以它是语句级别的记录方式； RedoLog 是在 InnoDB 存储引擎层面的操作，它是在 Mysql 后台线程中生成并写入到磁盘中的，所以它是事务级别的记录方式，一个事务操作完成以后才会被写入到 redo log 中。</li>
</ol>
<h4 id="数据库-cpu-飙升的话，要怎么处理呢？"><a href="#数据库-cpu-飙升的话，要怎么处理呢？" class="headerlink" title="数据库 cpu 飙升的话，要怎么处理呢？"></a>数据库 cpu 飙升的话，要怎么处理呢？</h4><p>第一步，排查问题</p>
<ul>
<li>使用 top 命令，找到 cpu 占用过高的进程是否是 mysqld</li>
<li>如果是，可以在 mysql 中通过 show processlist 查看当前的会话情况，确定是否有消耗资源的 SQL正在运行</li>
<li>找到消耗过高的 SQL，通过执行计划进行具体的分析</li>
</ul>
<p>第二步，处理方式</p>
<ul>
<li>如果确定是 SQL 问题，可以通过 SQL 的优化手段进行调整</li>
<li>重新执行 SQL 分析确认是否有达到优化的目的</li>
</ul>
<p>第三步，其他情况</p>
<p>如果不是 SQL 的问题导致，那就需要分析 CPU 飙高的这个时间段，Mysql 的整体并发连接数。如果有大量的请求连接进来，那我们就需要分析这个时间段业务的情况，再作出相应的调整。最后，如果是 Mysql 本身的参数并不是最优状态，那我们可以对 Mysql 服务节点的配置进行调整，比如缓存大小、线程池大小等</p>
<h4 id="为什么-SQL-语句不要过多地-join？"><a href="#为什么-SQL-语句不要过多地-join？" class="headerlink" title="为什么 SQL 语句不要过多地 join？"></a>为什么 SQL 语句不要过多地 join？</h4><ol>
<li>性能问题：每个 join 操作都需要对两个或多个表进行连接操作，这个操作需要消耗大量的计算资源和时间，如果 join 操作过多，会导致 SQL 的执行效率降低，从而影响整个系统的性能。</li>
<li>可读性和维护性问题：join 操作会使 SQL 语句变得复杂，难以理解和维护，特别是当 join 操作涉及多个表的时候，SQL 语句的复杂度会呈现指数级增长，给代码的可读性和可维护性带来挑战。</li>
</ol>
<h4 id="count-性能对比"><a href="#count-性能对比" class="headerlink" title="count 性能对比"></a>count 性能对比</h4><p>count，其实是一个聚合函数，聚合数据的总数</p>
<p><strong>count(*) ，也就是整条数据</strong>，由于整条数据肯定不会为 null，所以，专门做了优化，不会去取全部字段。直接扫描多源数据统计数据即可。</p>
<p><strong>count(1) 扫描到一条数据，直接返回一个数字 1，不会取扫描的字段，也不会去判断是否为 null。</strong></p>
<p>但是如果你 count（字段），有 2 种情况。</p>
<ol>
<li>首先去看字段是否能走索引，如果没索引，那么扫描数据不会走索引树，比有索引的字段慢。</li>
<li>字段是否可为 null，如果可为 null，那么必须去判断扫描出来的数据是否为 null，为 null 不统计，</li>
</ol>
<p>所以不可为 null 的比可为 null 的要快。</p>
<h4 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h4><ol>
<li>选取最适用的字段属性 ，尽可能减少定义字段宽度，尽量把字段设置 NOT NULL，例如 省份 、性别 最好适用 ENUM</li>
<li>使用连接（JOIN）来代替子查询</li>
<li>适用联合（UNION）来代替手动创建的临时表</li>
<li>事务处理</li>
<li>锁定表 、优化事务处理</li>
<li>适用外键 ， 优化锁定表</li>
<li>建立索引</li>
<li>优化查询语句</li>
</ol>
<h4 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h4><p>SQL 注入产生的原因： <strong>程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤， 导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行</strong>。</p>
<p>防止 SQL 注入的方式：</p>
<p>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置执行 sql 语句时使用addslashes 进行 sql 语句转换 Sql语句书写尽量不要省略双引号和单引号。</p>
<p>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。提高数据库表和字段的命名技巧 ，对一些重要的字段根据程序的特点命名 ， 取不易被猜到的</p>
<h4 id="解释-MySQL-外连接、-内连接与自连接的区别"><a href="#解释-MySQL-外连接、-内连接与自连接的区别" class="headerlink" title="解释 MySQL 外连接、 内连接与自连接的区别"></a>解释 MySQL 外连接、 内连接与自连接的区别</h4><p>交叉连接： <strong>交叉连接又叫笛卡尔积</strong> ，它是指不使用任何条件 ，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p>
<p>内连接则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中 ， 即内连接只连接匹配的行。</p>
<p>外连接其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行 ，这三种情况依次称之为左外连接 ， 右外连接 ， 和全外连接</p>
<h4 id="drop、delete、truncate的区别"><a href="#drop、delete、truncate的区别" class="headerlink" title="drop、delete、truncate的区别"></a>drop、delete、truncate的区别</h4><p>SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别</p>
<ul>
<li>delete用于删除表中的一行或多行记录，它可以与WHERE句一起使用来指定要删除的记录。</li>
<li>truncate用于快速删除表中的所有记录，重置任何自增的计数器(如自增的主键)</li>
<li>drop用于删除整个表结构及其数据。</li>
</ul>
<h4 id="分库分表之后，id主键如何处理？"><a href="#分库分表之后，id主键如何处理？" class="headerlink" title="分库分表之后，id主键如何处理？"></a>分库分表之后，id主键如何处理？</h4><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持。</p>
<ul>
<li><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标识比如文件名</li>
<li><strong>数据库自增id</strong>：两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li><strong>利用redis生成id</strong>：性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系 统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>
<li>分布式ID生成器</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="SkipList的索引过程，能否越两级搜索？"><a href="#SkipList的索引过程，能否越两级搜索？" class="headerlink" title="SkipList的索引过程，能否越两级搜索？"></a>SkipList的索引过程，能否越两级搜索？</h4><p>跳跃表主要由以下部分构成: </p>
<ul>
<li><p><strong>表头(head)</strong> ：负责维护跳跃表的节点指针。</p>
</li>
<li><p><strong>跳跃表节点</strong>：保存着元素值，以及多个层。</p>
</li>
<li><p><strong>层</strong>：保存着指向其他元素的指针。</p>
<p>高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</p>
</li>
<li><p><strong>表尾</strong>：全部由NULL组成，表示跳跃表的末尾。</p>
</li>
</ul>
<p><img src="/2024/05/20/mian-shi-zheng-li/image-20240522172744489.png"></p>
<p>在一个链表的基础上，增加了多层索引，这个层数是随机的。每一层索引都是原始链表的一个子集，并且索引元素的间隔逐层增大，这样就可以在较高的层级上进行快速搜索，从而减少搜索的时间复杂度。</p>
<h4 id="描述一下Redis的缓存淘汰机制"><a href="#描述一下Redis的缓存淘汰机制" class="headerlink" title="描述一下Redis的缓存淘汰机制"></a>描述一下Redis的缓存淘汰机制</h4><p>第一个方面：<br>当Redis使用的内存达到maxmemory参数配置的阈值的时候，Redis就会根据配置的内存淘汰策略。把访问频率不高的key从内存中移除。maxmemory默认情况是当前服务器的最大内存。</p>
<p>第二个方面：<br>Redis默认提供了8种缓存淘汰策略，这8种缓存淘汰策略总的来说，我认为可以归类成五种.</p>
<ul>
<li><p>第一种，采用LRU策略，就是把不经常使用的key淘汰掉</p>
</li>
<li><p>第二种， 采用LFU策略，它在LRU算法上做了优化，增加了数据访问次数，从而确保淘汰的是非热点key。</p>
</li>
<li><p>第三种，随机策略，也就是说随机删除一些key</p>
</li>
<li><p>第四种，ttl 策略，从设置了过期时间的key里面，挑选出过期时间最近的key进行优先淘汰</p>
</li>
<li><p>第五种，当内存不够的时候，直接报错，这是默认的策略。</p>
<p>这些策略可以在redis.conf文件中手动配置和修改，我们可以根据缓存的类型和缓存使用的场景来选择合适的淘汰策略。</p>
</li>
</ul>
<h4 id="说说Redis哈希槽的概念"><a href="#说说Redis哈希槽的概念" class="headerlink" title="说说Redis哈希槽的概念"></a>说说Redis哈希槽的概念</h4><p>Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h4 id="对Redis事务的理解"><a href="#对Redis事务的理解" class="headerlink" title="对Redis事务的理解"></a>对Redis事务的理解</h4><p>Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。</p>
<ul>
<li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</li>
<li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端</li>
</ul>
<h4 id="Redis为什么设计成单线程？"><a href="#Redis为什么设计成单线程？" class="headerlink" title="Redis为什么设计成单线程？"></a>Redis为什么设计成单线程？</h4><p>多线程处理会涉及锁，并且<strong>多线程处理会涉及线程切换而消耗 CPU</strong>。采用单线程，避免了不必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p>
<h4 id="假如有1亿个key，其中10w个key是以某个固定的已知的前缀开头的，怎么将它们全部找出来？"><a href="#假如有1亿个key，其中10w个key是以某个固定的已知的前缀开头的，怎么将它们全部找出来？" class="headerlink" title="假如有1亿个key，其中10w个key是以某个固定的已知的前缀开头的，怎么将它们全部找出来？"></a>假如有1亿个key，其中10w个key是以某个固定的已知的前缀开头的，怎么将它们全部找出来？</h4><p>可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p>
<ol>
<li><strong>使用keys命令</strong>：直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导 致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。</li>
<li><strong>使用scan命令</strong>：scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程，并且<strong>查找的数据可能存在重复，需要客户端操作去重</strong>。因为 scan 是通过<strong>游标方式查询</strong>的，所以不会导致 Redis 出现假死的问题。 Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。 scan 在检索的过程中，被删除的元素是不会被查询出来，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长。</li>
</ol>
<h4 id="怎么提高缓存命中率？"><a href="#怎么提高缓存命中率？" class="headerlink" title="怎么提高缓存命中率？"></a>怎么提高缓存命中率？</h4><ul>
<li>提前加载数据到缓存中；</li>
<li>增加缓存的存储空间，提高缓存的数据；</li>
<li>调整缓存的存储数据类型；</li>
<li>提升缓存的更新频率。</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="介绍下-Spring-IoC-的工作流程"><a href="#介绍下-Spring-IoC-的工作流程" class="headerlink" title="介绍下 Spring IoC 的工作流程"></a>介绍下 Spring IoC 的工作流程</h4><p>IOC 的全称是 Inversion Of Control，也就是控制反转，它的核心思想是把对象的管理权限交给容器。应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。</p>
<p>Spring 里面很多方式去定义 Bean，（如图）比如 XML 里面的〈bean〉标签、@Service、@Component、 @Repository、@Configuration 配置类中的@Bean 注解等等。Spring 在启动的时候，会去解析这些 Bean 然后保存到 IOC 容器里面。</p>
<p>Spring IOC 的工作流程大致可以分为两个阶段。</p>
<ol>
<li><strong>IOC 容器的初始化</strong>。根据程序中定义的 XML 或者注解等 Bean 的声明方式</li>
<li><strong>完成 Bean 初始化及依赖注入</strong>。通过反射针对没有设置 lazy-init 属性的单例 bean 进行初始化。完成 Bean 的依赖注入。</li>
</ol>
<h4 id="Spring是如何解决循环依赖的问题？"><a href="#Spring是如何解决循环依赖的问题？" class="headerlink" title="Spring是如何解决循环依赖的问题？"></a>Spring是如何解决循环依赖的问题？</h4><p>而 Spring 中设计了<strong>三级缓存</strong>来解决循环依赖问题，当我们去调用 getBean(）方法的时候，Spring 会先从一级缓存中去找到目标 Bean，如果发现一级缓存中没有便会去二级缓存中去找，而如果一、二级缓存中都没有找到，意味着该目标 Bean 还没有实例化。于是，Spring 容器会实例化目标 Bean（PS：刚初始化的 Bean 称为早期 Bean） 。然后，将目标 Bean 放入二级缓存中，同时，<strong>加上标记是否存在循环依赖</strong>。如果不存在循环依赖便会将目标 Bean 存入到二级缓存，否则，便会标记该 Bean 存在循环依赖，然后将等待下一次轮询赋值，也就是解析@Autowired 注解。等@Autowired 注解赋值完成后（PS：完成赋值的 Bean 称为成熟 Bean） ，会将目标 Bean 存入到一级缓存。</p>
<p>三级缓存是用来存储代理 Bean，当调用 getBean(）方法时，发现目标 Bean 需要通过代理工厂来创建，此时会将创建好的实例保存到三级缓存，最终也会将赋值好的 Bean 同步到一级缓存中。</p>
<p><img src="/2024/05/20/mian-shi-zheng-li/20240524102928.png"></p>
<h4 id="Spring-中哪些情况下，不能解决循环依赖问题？"><a href="#Spring-中哪些情况下，不能解决循环依赖问题？" class="headerlink" title="Spring 中哪些情况下，不能解决循环依赖问题？"></a>Spring 中哪些情况下，不能解决循环依赖问题？</h4><ol>
<li>多例 Bean 通过 setter 注入的情况，不能解决循环依赖问题</li>
<li>构造器注入的 Bean 的情况，不能解决循环依赖问题</li>
<li>单例的代理 Bean 通过 Setter 注入的情况，不能解决循环依赖问题</li>
<li>设置了@DependsOn 的 Bean 的情况，不能解决循环依赖问题</li>
</ol>
<h4 id="为什么要使用-Spring-框架？"><a href="#为什么要使用-Spring-框架？" class="headerlink" title="为什么要使用 Spring 框架？"></a>为什么要使用 Spring 框架？</h4><p>Spring 是一个轻量级应用框架，它提供了 <strong>IoC 和 AOP 这两个核心的功能</strong>。它的核心目的是简化企业级应用程序的开发，使得开发者只需要关心业务需求，不需要关心 Bean 的管理，以及通过切面增强功能减少代码的侵入性。</p>
<ul>
<li>轻量：Spring 是轻量的，基本的版本大约 2MB。</li>
<li>IOC/DI：Spring 通过 IOC 容器实现了 Bean 的生命周期的管理，以及通过 DI 实现依赖注入，从而实现了对象依赖的松耦合管理。</li>
<li>面向切面的编程（AOP)：Spring 支持面向切面的编程，从而把应用业务逻辑和系统服务分开。</li>
<li>MVC 框架：Spring MVC 提供了功能更加强大且更加灵活的 Web 框架支持</li>
<li>事务管理：Spring 通过 AOP 实现了事务的统一管理，对应用开发中的事务处理提供了非常灵活的支持</li>
</ul>
<h4 id="Spring-Bean的生命周期是怎么样的？"><a href="#Spring-Bean的生命周期是怎么样的？" class="headerlink" title="Spring Bean的生命周期是怎么样的？"></a>Spring Bean的生命周期是怎么样的？</h4><p>整个生命周期可以大致分为3个大的阶段，分别是：<strong>创建、使用、销毁</strong>。还可以进一步分为5个小的阶段: 实例化、初始化、注册Destruction回调、 Bean的正常使用以及Bean的销毁。</p>
<ol>
<li>实例化bean：反射生成对象</li>
<li>填充bean的属性</li>
<li>检查Aware回调的相关接口并设置相关依赖</li>
<li>调用Bean PostProcessor的前置处理方法</li>
<li>调用initmethod方法</li>
<li>调用Bean PostProcessor的后置处理方法 AOP</li>
<li>注册Destruction相关回调接口</li>
<li>获取到完整的对象，使用</li>
<li>销毁</li>
</ol>
<h4 id="Bean-的作用域有哪些？"><a href="#Bean-的作用域有哪些？" class="headerlink" title="Bean 的作用域有哪些？"></a>Bean 的作用域有哪些？</h4><p>Spring 框架里面的 IOC 容器，可以非常方便地去帮助我们管理应用里面的 Bean 对象实例。我们只需要按照 Spring 里面提供的 xml 或者注解等方式去告诉 IOC 容器，哪些 Bean 需要被 IOC 容器管理就行了</p>
<p>Bean 对象实例的管理，那意味着这些实例，是存在生命周期，也就是所谓的作用域。</p>
<ul>
<li>singleton， 也就是单例，意味着在整个 Spring 容器中只会存在一个 Bean 实例。</li>
<li>prototype，翻译成原型，意味着每次从 IOC 容器去获取指定 Bean 的时候，都会返回一个新的实例对象。</li>
</ul>
<p>但是在基于 Spring 框架下的 Web 应用里面，增加了一个会话维度来控制 Bean 的生命周期，主要有三个选择</p>
<ul>
<li>request， 针对每一次 http 请求，都会创建一个新的 Bean</li>
<li>session，以 sesssion 会话为纬度，同一个 session 共享同一个 Bean 实例，不同的 session 产生不同的 Bean 实例</li>
<li>globalSession，针对全局 session 纬度，共享同一个 Bean 实例</li>
</ul>
<h4 id="有哪些方式可以把-Bean-注入-IOC-容器？"><a href="#有哪些方式可以把-Bean-注入-IOC-容器？" class="headerlink" title="有哪些方式可以把 Bean 注入 IOC 容器？"></a>有哪些方式可以把 Bean 注入 IOC 容器？</h4><ol>
<li>使用 <strong>xml 的方式</strong>来声明 Bean 的定义，Spring 容器在启动的时候会加载并解析这个 xml，把 bean装载到 IOC 容器中。</li>
<li>使用**@CompontScan 注解**来扫描声明了@Controller、@Service、@Repository、@Component注解的类。</li>
<li>使用**@Configuration 注解声明配置类**，并使用@Bean 注解实现 Bean 的定义，这种方式其实是xml 配置方式的一种演变，是 Spring 迈入到无配置化时代的里程碑。</li>
<li>使用**@Import 注解**，导入配置类或者普通的 Bean</li>
<li>使用 <strong>FactoryBean 工厂 bean</strong>，动态构建一个 Bean 实例，Spring Cloud OpenFeign 里面的动态代理实例就是使用 FactoryBean 来实现的。</li>
<li>实现 <strong>ImportBeanDefinitionRegistrar 接口</strong>，可以动态注入 Bean 实例。这个在 Spring Boot 里面的启动注解有用到。</li>
<li>实现 ImportSelector 接口，动态批量注入配置类或者 Bean 对象，这个在 Spring Boot 里面的自动装配机制里面有用到。</li>
</ol>
<h4 id="Spring-中-BeanFactory-和-FactoryBean-的区别"><a href="#Spring-中-BeanFactory-和-FactoryBean-的区别" class="headerlink" title="Spring 中 BeanFactory 和 FactoryBean 的区别"></a>Spring 中 BeanFactory 和 FactoryBean 的区别</h4><p>Spring 里面的核心功能是 IOC 容器，所谓 IOC 容器呢，本质上就是一个 Bean 的容器或者是一个 Bean 的工厂。它能够根据 xml 里面声明的 Bean 配置进行 bean 的加载和初始化，然后 BeanFactory 来生产我们需要的各种各样的 Bean。</p>
<ul>
<li><strong>BeanFactory 是所有 Spring Bean 容器的顶级接口</strong>，它为 Spring 的容器定义了一套规范，并提供像 getBean 这样的方法从容器中获取指定的 Bean 实例。</li>
<li>BeanFactory 在产生 Bean 的同时，还提供了<strong>解决 Bean 之间的依赖注入的能力</strong>，也就是所谓的DI。</li>
</ul>
<p>FactoryBean 是<strong>一个工厂 Bean，它是一个接口，主要的功能是动态生成某一个类型的 Bean 的实例</strong>，也就是说，我们可以自定义一个 Bean 并且加载到 IOC 容器里面。它里面有一个重要的方法叫 getObject()，这个方法里面就是用来实现动态构建 Bean 的过程。</p>
<h4 id="Spring-中，有两个-id-相同的-bean，会报错吗，如果会报错，在哪个阶段报错"><a href="#Spring-中，有两个-id-相同的-bean，会报错吗，如果会报错，在哪个阶段报错" class="headerlink" title="Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错"></a>Spring 中，有两个 id 相同的 bean，会报错吗，如果会报错，在哪个阶段报错</h4><p>在<strong>同一个 XML 配置文件里面，不能存在 id 相同的两个 bean</strong>，否则 spring 容器启动的时候会报错。因为 id 这个属性表示一个 Bean 的唯一标志符号，所以 Spring 在启动的时候会去验证 id 的唯一性，一旦发现重复就会报错。但是在两个不同的 Spring 配置文件里面，可以存在 id 相同的两个 bean。</p>
<p>Spring3.x 里面提供@Configuration 注解去声明一个配置类，然后使用@Bean 注解实现Bean 的声明，这种方式完全取代了 XML。如果我们在同一个配置类里面声明多个相同名字的 bean，在 <strong>Spring IOC 容器中只会注册第一个声明的 Bean 的实例</strong>。后续重复名字的 Bean 就不会再注册了。</p>
<h4 id="Conditional-注解有什么用？"><a href="#Conditional-注解有什么用？" class="headerlink" title="@Conditional 注解有什么用？"></a>@Conditional 注解有什么用？</h4><p>@Conditional 注解的作用是<strong>为 Bean 的装载提供了一个条件判断</strong>。只有满足条件的情况下，Spring 才会把当前 Bean 装载到 IOC 容器中。这个条件的实现逻辑，我们<strong>可以实现 Condition 接口并重写 matches 方法自己去实现。</strong>所以@Conditional 注解增加了 Bean 装载的灵活性。在Spring Boot里面，对@Conditional注解做了更进一步的扩展，比如增加了@ConditionalOnClass、 @ConditionalOnBean等注解，使得我们在使用的过程中不再需要去写条件的逻辑。 </p>
<h4 id="为什么有些公司禁止使用-Transactional-声明式事务？"><a href="#为什么有些公司禁止使用-Transactional-声明式事务？" class="headerlink" title="为什么有些公司禁止使用@Transactional 声明式事务？"></a>为什么有些公司禁止使用@Transactional 声明式事务？</h4><ol>
<li>在方法上增加@Transaction 声明式事务，如果一个方法中的存在较多耗时操作，就容易引发长事物问题，而长事物会带来锁的竞争影响性能，同时也会导致数据库连接池被耗尽，影响程序的正常执行。</li>
<li>如果方法存在嵌套调用，而被嵌套调用的方法也声明了@Transaction 事物，就会出现事物的嵌套调用行为，容易引起事物的混乱造成程序运行结果出现异常</li>
<li>@Transaction 声明式事务是将事物控制逻辑放在注解中，如果项目的复杂度增加，事务的控制可能会变得更加复杂，导致代码可读性和维护性下降。</li>
</ol>
<p>所以，为了避免这类问题，有些公司会推荐使用编程式事务，这样可以更加灵活地控制事务的范围，减少事务的锁定时间，提高系统的性能。</p>
<h4 id="过滤器和拦截器有什么区别？"><a href="#过滤器和拦截器有什么区别？" class="headerlink" title="过滤器和拦截器有什么区别？"></a>过滤器和拦截器有什么区别？</h4><ol>
<li>运行顺序不同：过滤器是在 Servlet 容器接收到请求之后，但在 Servlet 被调用之前运行的；而拦截器则是在 Servlet 被调用之后，但在响应被发送到客户端之前运行的。<br>Filter➡️Servlet➡️Interceptor➡️Controller</li>
<li>配置方式不同：过滤器是在 web.xml 中进行配置；而拦截器的配置则是在 Spring 的配置文件中进行配置，或者使用注解进行配置</li>
<li>Filter 依赖于 Servlet 容器，而 Interceptor 不依赖于 Servlet 容器</li>
<li><strong>Filter在过滤时只能对 request 和 response 进行操作</strong>，而 interceptor 可以对 request、response、handler、modelAndView、exception 进行操作。</li>
</ol>
<h4 id="Component，-Controller，-Repository，-Service-有何区别？"><a href="#Component，-Controller，-Repository，-Service-有何区别？" class="headerlink" title="@Component，@Controller，@Repository，@Service 有何区别？"></a>@Component，@Controller，@Repository，@Service 有何区别？</h4><p><strong>@Component</strong> ：这将 java 类标记为 bean 。 它是任何 Spring 管理组件的通用构造型 。 spring 的 组件 扫 描机 制 现在 可 以将 其 拾取 并 将其 拉 入应 用 程序 环 境 中 。 </p>
<p><strong>@Controller</strong>：这将一个类标记为 Spring Web MVC 控制器。标有它的Bean会自动导入到 IoC 容 器中 。</p>
<p> <strong>@Service</strong>：此注解是组件注解的特化 。 它不会对 @Component 注解提供任何其他行为。可以在服务层类中使用@Service 而不是@Component，因为它以更好的方式指定了意图。 </p>
<p><strong>@ Repository</strong>：这个注解是具有类似用途和功能的@Component注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为Spring DataAccess Exception。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><h4 id="Spring-Boot中自动装配机制的原理"><a href="#Spring-Boot中自动装配机制的原理" class="headerlink" title="Spring Boot中自动装配机制的原理"></a>Spring Boot中自动装配机制的原理</h4><p>自动装配，简单来说就是自动把第三方组件的 Bean 装载到 Spring IOC 器里面，不需要开发人员再去写 Bean 的装配配置。在 Spring Boot 应用里面，只需要<strong>在启动类加上@SpringBootApplication 注解就可以实现自动装配。</strong> @SpringBootApplication 是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。<br>SpringBoot 是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。</p>
<h4 id="spring-boot的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#spring-boot的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="spring boot的核心注解是哪个？它主要由哪几个注解组成的？"></a>spring boot的核心注解是哪个？它主要由哪几个注解组成的？</h4><p>启动类上面的注解是**@SpringBootApplication**，它也是 Spring Boot 的核心注解，主要组合包含了以下3个注解：</p>
<ol>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：<br>@SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan：Spring 组件扫描。</li>
</ol>
<h4 id="运行spring-boot有哪几种方式？"><a href="#运行spring-boot有哪几种方式？" class="headerlink" title="运行spring boot有哪几种方式？"></a>运行spring boot有哪几种方式？</h4><ol>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven/Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ol>
<h4 id="如何使用实现异常处理？"><a href="#如何使用实现异常处理？" class="headerlink" title="如何使用实现异常处理？"></a>如何使用实现异常处理？</h4><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul>
<li><strong>加载启动类</strong>：当SpringBoot项目启动时，它会在当前工作目录下<strong>寻找有@SpringBootApplication注解标识的类</strong>，并把这个类作为应用程序的入口点。这个注解包含了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个注解的功能。SpringBoot通过扫描启动类所在的包及子包，自动配置相应的Bean。如果找不到这样的主类，则会打印错误信息并退出。</li>
<li><strong>加载配置文件</strong>：SpringBoot会自动扫描当前项目的resources目录，并<strong>加载其中的application.properties或application.yml等配置文件</strong>。这些配置文件中包含了应用程序的各种参数，例如数据库连接信息、日志级别等等。SpringBoot会读取配置文件中的参数，并将它们转换成Environment对象中的属性。同时，它还会扫描当前项目中的所有Bean，并将它们注册到ApplicationContext中。此外，SpringBoot程序默认从application.properties或application.yml中加载配置，也可以通过在启动类上标注@PropertySource来引入其他的配置文件。</li>
<li><strong>创建Spring容器</strong>：SpringBoot使用SpringBootApplication类创建Spring容器。SpringApplication类是SpringBoot的核心类，它提供了配置和管理Bean的方法。</li>
</ul>
<p>SpringBoot的启动流程主要包括加载启动类、加载配置文件和创建Spring容器三个步骤。这个流程使得SpringBoot能够快速地启动并运行应用程序，同时提供了灵活的配置和自动装配功能，使得开发者可以更加高效地开发Spring应用程序。</p>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="简述你对-Spring-MVC-的理解"><a href="#简述你对-Spring-MVC-的理解" class="headerlink" title="简述你对 Spring MVC 的理解"></a>简述你对 Spring MVC 的理解</h4><p>实现了 Web MVC 设计模式，<strong>请求驱动类型的轻量级 Web框架</strong>。采用了 MVC 架构模式的思想，通过把 Model，View，Controller 分离，将 Web 层进行职责解耦，从而把复杂的 Web 应用分成逻辑清晰的几个组件，共有九大组件。涉及请求处理响应的核心组件分别是：（1）HandlerMapping；（2）HandlerAdapter；（3）ViewResolver</p>
<ol>
<li>HandlerMapping 回到调用 HandlerAdapter</li>
<li>HandlerAdapter 会返回 ModelAndView</li>
<li>ModelAndView 根据用户传入参数得到 ViewResolvers</li>
<li>ViewResolvers 会将用户传入的参数封装为 View，交给引擎进行渲染。</li>
</ol>
<h4 id="Spring-MVC-的执行流程？"><a href="#Spring-MVC-的执行流程？" class="headerlink" title="Spring MVC 的执行流程？"></a>Spring MVC 的执行流程？</h4><ol>
<li>用户发起请求，请求先被 Servlet 拦截转发给 Spring MVC 框架</li>
<li>Spring MVC 里面的 DispatcherSerlvet 核心控制器，会接收到请求并转发给 HandlerMapping</li>
<li>HandlerMapping 负责解析请求，根据请求信息和配置信息找到匹配的 Controller 类，不过这里如果有配置拦截器，就会按照顺序执行拦截器里面的 preHandle 方法</li>
<li>找到匹配的 Controller 以后，把请求参数传递给 Controller 里面的方法</li>
<li>Controller 中的方法执行完以后，会返回一个 ModeAndView，这里面会包括视图名称和需要传递给视图的模型数据</li>
<li>视图解析器根据名称找到视图，然后把数据模型填充到视图里面再渲染成 Html 内容返回给客户端</li>
</ol>
<p><img src="/2024/05/20/mian-shi-zheng-li/20240524133454.png"></p>
<p>SpringMVC<strong>主要</strong>负责的就是</p>
<ul>
<li>controller如何接收请求和数据</li>
<li>如何将请求和数据转发给业务层</li>
<li>如何将响应数据转换成json发回到前端</li>
</ul>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul>
<li><strong>@PostMapping</strong>：处理post请求,可以自动将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AF%B7%E6%B1%82%E4%BD%93&amp;spm=1001.2101.3001.7020">请求体</a>中的数据转换为 Java 对象，并将返回值转换为 JSON 或 XML 格式，方便客户端解析处理</li>
<li><strong>@GetMapping</strong>：处理get请求</li>
<li><strong>@PutMapping</strong>：处理put请求</li>
<li><strong>@ResponseBody</strong>：将java对象转为json格式的数据。将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</li>
</ul>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><h4 id="你对-Spring-Cloud-的理解"><a href="#你对-Spring-Cloud-的理解" class="headerlink" title="你对 Spring Cloud 的理解"></a>你对 Spring Cloud 的理解</h4><p>Spring Cloud 是一套分布式微服务的技术解决方案，它提供了快速构建分布式系统的常用的一些组件比如说配置管理、服务的注册与发现、服务调用的负载均衡、资源隔离、熔断降级等等</p>
<p>我们项目采用的是Spring Cloud Alibaba 是基于阿里巴巴开源组件集成的一套微服务解决方案，其中包括：</p>
<ol>
<li>Dubbo——消息通讯</li>
<li>Nacos——服务注册与发现</li>
<li>Seata——事务隔离</li>
<li>Sentinel——熔断降级</li>
</ol>
<p>有了 Spring Cloud 这样的技术生态，使得我们在落地微服务架构时。不用去考虑第三方技术集成带来额外成本，只要通过配置组件来完成架构下的技术问题，从而可以让我们更加侧重性能方面</p>
<h4 id="什么是服务熔断？什么是服务降级？"><a href="#什么是服务熔断？什么是服务降级？" class="headerlink" title="什么是服务熔断？什么是服务降级？"></a>什么是服务熔断？什么是服务降级？</h4><p><strong>熔断机制是应对雪崩效应的一种微服务链路保护机制</strong>。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在 SpringCloud 框架里熔断机制通过 Hystrix 实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是 5 秒内调用 20 次，如果失败，就会启动熔断机制。</p>
<p><strong>服务降级，一般是从整体负荷考虑</strong>。就是当某个服务熔断之后，服务器将不再被调用，此时客户端 可以自己准备一个本地的 fallback 回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。</p>
<h4 id="springboot和springcloud的区别"><a href="#springboot和springcloud的区别" class="headerlink" title="springboot和springcloud的区别"></a>springboot和springcloud的区别</h4><ul>
<li><strong>SpringBoot 专注于快速方便地开发单个个体微服务。SpringCloud 是关注全局的微服务协调整理治理框架</strong>，它将 SpringBoot 开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策精选、分布式会话等集成服务</li>
<li>SpringBoot 可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开 SpringBoot ，属于依赖的关系。</li>
<li>SpringBoot 专注于快速、方便地开发单个微服务个体，SpringCloud 关注全局的服务治理框架。</li>
</ul>
<h3 id="MyBatis面试题"><a href="#MyBatis面试题" class="headerlink" title="MyBatis面试题"></a>MyBatis面试题</h3><h4 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis ?"></a>什么是Mybatis ?</h4><ol>
<li>Mybatis 是一个半ORM (对象关系映射) 框架，它内部封装了JDBC ，开发时只需<br>要关注SQL语句本身， 不需要花费精力去处理加载驱动、创建连接、创建<br>statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</li>
<li>MyBatis 可以使用XML或注解来配置和映射原生信息，将POJO 映射成数据库中的<br>记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li>
<li>通过xml文件或注解的方式将要执行的各种statement配置起来，并通过java对象和<br>statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。(从执行sql到返回result的过程)。</li>
</ol>
<p><strong>优点</strong>：基于SQL语句编程，灵活。能够与Spring很好的集成。提供映射标签，支持对象与数据库的ORM字段关系映射。提供XML标签，支持编写动态SQL语句，并可重用。</p>
<p><strong>缺点</strong>：SQL语句的编写工作量大。依赖于数据库，导致数据库移植性差，不能随意更改数据库。</p>
<p><strong>适用场景</strong>：MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。对性能要求高，或者需求变化较多的项目。</p>
<h4 id="Mybatis-是如何进行分页的"><a href="#Mybatis-是如何进行分页的" class="headerlink" title="Mybatis 是如何进行分页的"></a>Mybatis 是如何进行分页的</h4><p>数据进行分页是最基础的功能，一般可以把分页分成两类：</p>
<ol>
<li>逻辑分页，先查询出所有的数据缓存到内存，再根据业务相关需求，从内存数据中筛选出合适的数据进行分页。</li>
<li>物理分页 ，直接利用数据库支持的分页语法来实现，比如 Mysql 里面提供了分页关键词 Limit</li>
</ol>
<p>Mybatis 提供了四种分页方式：</p>
<ol>
<li>在 Mybatis Mapper 配置文件里面<strong>直接写分页 SQL</strong>，这种方式比较灵活，实现也简单。</li>
<li><strong>RowBounds 实现逻辑分页</strong>，也就是一次性加载所有符合查询条件的目标数据，根据分页参数值在内存中实现分页。这种方式不适合数据量较大的场景，而且有可能会频繁访问数据库造成比较大的压力。</li>
<li><strong>Interceptor 拦截器实现</strong>，通过拦截需要分页的 select 语句，然后在这个 sql 语句里面动态拼接分页关键字，从而实现分页查询。</li>
<li>插件（PageHelper）及（MyBaits-Plus、tkmybatis）框架实现。这些插件本质上也是使用 Mybatis 的拦截器来实现的。只是他们帮我们实现了扩展和封装，节省了分页扩展封装的工作量，在实际开发中，只需要拿来即用即可。</li>
</ol>
<h4 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h4><p><strong>#{是预编译处理 ， ${}是字符串替换</strong>。Mybatis 在处理#{}时 ，<strong>会将 sql 中的#{}替换为？号</strong> ，调用 PreparedStatement 的 set 方法来赋值；Mybatis 在处理${}时 ， <strong>就是把${}替换成变量的值</strong>。使用#{}可以有效地防止 SQL 注入 ， 提高系统安全性。</p>
<h4 id="说说的缓存机制："><a href="#说说的缓存机制：" class="headerlink" title="说说的缓存机制："></a>说说的缓存机制：</h4><p><strong>一级缓存localCache</strong>：在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的 SQL ，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存， 避免直接对数据库进行查询，提高性能。<br>每个 SqlSession 中持有了 Executor，每个 Executor 中有一个 LocalCache。当用户发起查询时， MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，如果缓存命中 的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 LocalCache，最后 返回结果给用户。</p>
<p><strong>二级缓存</strong>：在上文中提到的一级缓存中，其最大的共享范围就是一个 SqlSession 内部，如果多个SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor 装饰Executor，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询。</p>
<p>当开启缓存后，数据的查询执行的流程为：二级缓存➡️一级缓存➡️数据库</p>
<ol>
<li><p>MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时粒度更加细，能够到 namespace 级别，通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强。</p>
</li>
<li><p>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p>
</li>
<li><p>在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直接使用 Redis、 Memcached 等分布式缓存可能成本更低，安全性也更高。</p>
</li>
</ol>
<h4 id="SqlSession和HttpSession区别"><a href="#SqlSession和HttpSession区别" class="headerlink" title="SqlSession和HttpSession区别"></a>SqlSession和HttpSession区别</h4><ul>
<li>HttpSession：工作在Web服务器上，属于表述层。代表浏览器和Web服务器之间的会话。</li>
<li>SqlSession：不依赖Web服务器，属于持久化层。代表java程序和数据库之间的会话。</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="什么是分布式系统？和集群的区别？"><a href="#什么是分布式系统？和集群的区别？" class="headerlink" title="什么是分布式系统？和集群的区别？"></a>什么是分布式系统？和集群的区别？</h4><p>**分布式(distributed)**指在多台不同的服务器中部署不同的服务模块，过远程调用协同工作，对外提供服务。</p>
<p>**集群(cluster)**指在多台不同的服务器中部署相同应用或服务模块，构成一个集群， 过负载均衡设备对外提供服务。</p>
<h4 id="什么是分布式系统的一致性？"><a href="#什么是分布式系统的一致性？" class="headerlink" title="什么是分布式系统的一致性？"></a>什么是分布式系统的一致性？</h4><ul>
<li>强一致性模型(Strong Consistency) :在强一致性模型下，系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。这包括线性一致性(Linearizability) 、顺序一致性(Sequential Consistency)和严格可串行性(Strict Serializability)子模型。</li>
<li>弱一致性模型(Weak Consistency) :弱一致性模型放宽了一致性保证，它允许在不同节点之间的数据访问之间存在一定程度的不一致性, 以换取更高的性能和可用性。这包括因果一致性(Causal Consistency)、会话一致性(Session Consistency)和单调一致性(Monotonic Consistency)等子模型。弱一致性模型通常更注重可用性，允许一定程度的数据不一致性。</li>
<li>最终一致性模型(Eventual Consistency) :最终一致性模型是一种最大程度放宽了一致性要求的模型。它允许在系统发生分区或网络故障后，经过一段时间，系統将最终达到一致状态。这个模型在某些情况下提供了很高的可用性，但在一段时间内可能会出现数据不一致的情况。</li>
</ul>
<h4 id="什么是CAP理论，为什么不能同时满足？"><a href="#什么是CAP理论，为什么不能同时满足？" class="headerlink" title="什么是CAP理论，为什么不能同时满足？"></a>什么是CAP理论，为什么不能同时满足？</h4><ul>
<li><strong>一致性：</strong>每次读取都会收到最新的写入数据或错误信息。</li>
<li><strong>可用性：</strong>每个请求都会收到(非错误的)响应，但不能保证响应包含最新的写入数据。</li>
<li><strong>分区容忍性：</strong>尽管网络节点之间会弃(或延迟)任意数量的消息，系统仍然能够继续运行。</li>
</ul>
<h4 id="什么是分布式BASE理论？"><a href="#什么是分布式BASE理论？" class="headerlink" title="什么是分布式BASE理论？"></a>什么是分布式BASE理论？</h4><p>CAP理论的一致性是强一致性，BASE：基本可用(Basically Available)、软状态(Soft State)、最终一致性(Eventual Consistency)，做到最终一致性。</p>
<ul>
<li>基本可用：是指分布式系统在出现故障的时报，分许损失部分可用性(降级)， 即保证核心可用。</li>
<li>软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</li>
<li>最终一致性：是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li>
</ul>
<h4 id="分布式锁有几种实现方式？"><a href="#分布式锁有几种实现方式？" class="headerlink" title="分布式锁有几种实现方式？"></a>分布式锁有几种实现方式？</h4><p>其中数据库的实现可以依赖悲观锁以及数据库表记录来实现，通过Redis的实现可以考虑使用setnx、 redission以及redlock实现。</p>
<h4 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h4><p>分布式事务是指在分布式系统中涉及到多个数据库或多个应用程序之间的事务处理，这些数据库或应用程序可能分布在不同的物理节点上，甚至可能位于不同的地理位置。在分布式事务中，需要确保所有参与者的事务操作都能够保持一致性，即所有参与者的事务要么全部提交成功，要么全部回滚。</p>
<h4 id="如何基于本地消息表实现分布式事务？"><a href="#如何基于本地消息表实现分布式事务？" class="headerlink" title="如何基于本地消息表实现分布式事务？"></a>如何基于本地消息表实现分布式事务？</h4><p>这个方案的主要思想是<strong>将分布式事务拆分为本地事务和消息事务两个部分，</strong>本地事务在本地数据库中进行提交或回滚，而消息事务则将消息写入消息中间件中，实现消息的可靠投递和顺序性。</p>
<p>1.一般来说的做法是，在发送消息之前，先创建一条本地消息，并且保证写本地业务数据的操作，和，写体地消息记录的操作在同一个事务中。这样就能确保只要业务操作成功，本地消息一可以写成功。2.然后再基于本地消息，调用MQ发送远程消息。3.消息发出之后，等待消费者消费，在消费者端，接收到消息之后，做业务处理，处理成功后再修改本地消息表的状态。</p>
<h4 id="怎么实现分布式Session？"><a href="#怎么实现分布式Session？" class="headerlink" title="怎么实现分布式Session？"></a>怎么实现分布式Session？</h4><ul>
<li><strong>客户端存储：</strong>用户登录后，将Session信息保存在客户端，用户在每次请求的时候，通过客户端的cookie把session信息带过来。这个方法因为要把session暴露给客户端，存在安全风险。</li>
<li><strong>基于<strong><strong>分布式</strong></strong>存储：</strong>将Session数据保存在分布式存储系统中，如分布式文件系统、分布式数据库等。不同服务器可以共享同一个分布式存储，通过过Session ID查找对应的Session数据。需要依赖第三方存储，如Redis、数据库等。</li>
<li><strong>粘性Session：</strong>这个方案指的是把一个用户固定的路由到指定的机器上，这样只需要这台服务器中保存了session即可，不要做分布式存储。但是这个存在的问题就是可能存在单点故障的问题。</li>
<li><strong>Session复制：</strong>当用户的Session在某个服务器产生之后，通过复制的机制，将他同步到其他的服务器中。这个案的缺点是有可能有延迟。</li>
</ul>
<h4 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h4><p>负载均衡(Load Balance) , 意思是将负载(工作任务,访问请求)进行平衡、分摊到多个操作单元(服务器，组件)上进行执行。是解决高性能，单点故障(高可用)，扩展性(水平伸缩)的终极解决方案。</p>
<h4 id="如何解决接口幂等的问题？"><a href="#如何解决接口幂等的问题？" class="headerlink" title="如何解决接口幂等的问题？"></a>如何解决接口幂等的问题？</h4><ol>
<li>一锁：第一步，先加锁。可以加分布式锁、或者悲观锁都可以。但是一定要是一个互斥锁！</li>
<li>二判：第二步，进行幂等性判断。可以基于状态机、流水表、唯一性索引等等进行重复操作的判断。</li>
<li>三更新：第三步，进行数据的更新，将数据进行持久化。</li>
</ol>
<h4 id="TCC是强一致性还是最终一致性？"><a href="#TCC是强一致性还是最终一致性？" class="headerlink" title="TCC是强一致性还是最终一致性？"></a>TCC是强一致性还是最终一致性？</h4><ul>
<li>Try阶段：尝试执行所有操作，并锁定所资源以准备提交。</li>
<li>Confirm阶段：如果所有的Try操作成功，那么执行Confirm操作，最终提交事务。</li>
<li>Cancel阶段：如果任何Try操作失败，或者确认过程中遇到问题，执行Cance|操作来回滚所有的操作，释放锁定的资源。</li>
</ul>
<p>在理想情况下，如果所有参与组件能正确执行其try、Confirm、Cancel逻辑，并且系统之间的通信是可靠的，那么TCC是可以提供强一致性的。</p>
<h4 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h4><p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换等功能。网关主要做了两件事情：<strong>请求转发</strong> + <strong>请求过滤</strong>。</p>
<h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h4><p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>
<p>具体流程：</p>
<ol>
<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>
<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。</li>
<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>
<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。</li>
<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端</li>
</ol>
<p>客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p>
<h4 id="Spring-Cloud-Gateway限流原理"><a href="#Spring-Cloud-Gateway限流原理" class="headerlink" title="Spring Cloud Gateway限流原理"></a>Spring Cloud Gateway限流原理</h4><p><img src="/2024/05/20/mian-shi-zheng-li/20240531102632.png"></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="请说一下网络四元组"><a href="#请说一下网络四元组" class="headerlink" title="请说一下网络四元组"></a>请说一下网络四元组</h4><p>四元组，简单理解就是在 TCP 协议中，去确定一个客户端连接的组成要素，它包括<strong>源 IP 地址、目标 IP地址、源端口号、目标端口号</strong>。<br>一个 Server 端可以接收多个客户端的连接，TCP 是全双工协议，也就是说数据允许在连接的两个方向上同时传输，因此这里的客户端，如果是反向通信，它又变成了服务端。当一个客户端和服务端建立一个 TCP 连接的时候，通过源 IP 地址、目标 IP 地址、源端口号、目标端口号来确定一个唯一的 TCP 连接。因为服务器的 IP 和端口是不变的，只要客户端的 IP 和端口彼此不同就 OK 了。</p>
<h4 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h4><p>常见的远程通信方式，有基于 REST 架构的 HTTP 协议，以及 RPC 框架。</p>
<p><strong>远程调用是指跨进程的功能调用</strong>，跨进程可以理解成一个计算机节点的多个进程，或者多个计算机节点的多个进程。</p>
<p>Remote Procedure Call，翻译过来就是远程过程调用，它是<strong>一种通过网络从远程计算机程序上请求服务</strong>，而不需要了解底层网络技术的协议，凡是符合该协议的框架，我们都可以称它为 RPC 框架。<strong>要实现 RPC，需要通过网络传输数据，并对调用的过程进行封装。</strong></p>
<p><img src="/2024/05/20/mian-shi-zheng-li/20240524103340.png"></p>
<p>一个完整的 RPC 架构里面包含了四个核心的组件，分别是 Client，Server，Client Stub 以及Server Stub：</p>
<ol>
<li>客户端（Client），服务的调用方。</li>
<li>服务端（Server），真正的服务提供者。</li>
<li>客户端存根（Client Stub），存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端存根（Server Stub），接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ol>
<p>在分布式架构中，原本的单体应用被拆分成多个独立部署的服务分布在计算机网络上，这些服务必然需要通过网络进行数据交互。而 RPC 框架就是解决在分布式架构中的各个业务服务彼此的网络通信问题。</p>
<h4 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h4><p><strong>Cookie，它是客户端浏览器用来保存服务端数据的一种机制</strong>。当通过浏览器进行网页访问的时候，服务器可以把某一些状态数据以 key-value 的方式写入到 Cookie 里面存储到客户端浏览器。然后客户端下一次再访问服务器的时候，就可以携带这些状态数据发送到服务器端，服务端可以根据 Cookie 里面携带的内容来识别使用者。</p>
<p>Session 表示一个会话，它是属于服务器端的容器对象，默认情况下，针对每一个浏览器的请求。Servlet 容器都会分配一个 Session。Session 本质上是一个 ConcurrentHashMap，可以存储当前会话产生的一些状态数据。</p>
<p>Http 协议本身是一个无状态协议，也就是服务器并不知道客户端发送过来的多次请求是属于同一个用户。所以 Session 是用来弥补 Http 无状态的不足，简单来说，服务器端可以利用 session 来存储客户端在同一个会话里面的多次请求记录。<strong>基于服务端的 session 存储机制，再结合客户端的 Cookie 机制，就可以实现有状态的 Http 协议。</strong></p>
<h4 id="Http-协议和-RPC-协议有什么区别？"><a href="#Http-协议和-RPC-协议有什么区别？" class="headerlink" title="Http 协议和 RPC 协议有什么区别？"></a>Http 协议和 RPC 协议有什么区别？</h4><ul>
<li>从功能特性来说：http 是一个属于<strong>应用层的超文本传输协议</strong>，是万维网数据通信的基础，主要服务在网页端和服务端的数据传输上。RPC 是一个远程过程调用协议，它的定位是实现不同计算机应用之间的数据通信。</li>
<li>从实现原理来说：http 协议是一个已经实现并且成熟的应用层协议，它定义了通信的报文格式 Request Body和 Request Header，以及 Response Body 和 Response Header。RPC 只是一种协议的规范，它并没有具体实现，只有<strong>按照 RPC 通信协议规范实现的通信框架，也就是 RPC 框架</strong>，才是协议的具体实现，比如 Dubbo、gRPC 等。</li>
</ul>
<p>从这个层面来说，http 是成熟的应用协议，而 RPC 只是定义了不同服务之间的通信规范。</p>
<ul>
<li>从应用层面来说，http 协议和实现了 RPC 协议的框架都能够实现跨网络节点的服务之间通信，并且他们底层都是使用 TCP 协议作为通信基础。RPC 的网络通信层也可以使用 HTTP 协议来实现。</li>
</ul>
<h4 id="Get和Post请求有哪些区别？"><a href="#Get和Post请求有哪些区别？" class="headerlink" title="Get和Post请求有哪些区别？"></a>Get和Post请求有哪些区别？</h4><p>用途：<strong>get 请求用来从服务器获取资源；post 请求用来向服务器提交数据</strong>。</p>
<p>表单的提交方式：get请求直接将表单数据以baidu.com/action?name1=value1&amp;name2 =value2），多个参数参数值需要用 &amp; 连接起来并且拼接到action后面；post 请求<strong>将表单数据放到请求头或者请求的消息体</strong>。</p>
<p>传输数据的大小限制：get 请求传输的数据<strong>受到 URL 长度的限制</strong>，而 URL 长度是由浏览器决定的；post 请求传输数据的大小理论上来说是<strong>没有限制</strong>的。</p>
<p>参数的编码：get 请求的参数会在<strong>地址栏明文显示</strong>，使用 URL 编码的文本格式传递参数；post 请求使用<strong>二进制数据多重编码传递参数</strong>。</p>
<p>缓存：get 请求可以被浏览器缓存被收藏为标签；post 请求不会被缓存也不能被收藏为标签。</p>
<h4 id="说说HTTP、TCP、Socket的关系是什么？"><a href="#说说HTTP、TCP、Socket的关系是什么？" class="headerlink" title="说说HTTP、TCP、Socket的关系是什么？"></a>说说HTTP、TCP、Socket的关系是什么？</h4><ul>
<li>TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。</li>
<li>HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
<li>Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<p>综上所述：</p>
<ul>
<li>需要 IP 协议来连接网络</li>
<li>TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。</li>
<li>HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。</li>
</ul>
<h4 id="HTTP的长连接与短连接的区别"><a href="#HTTP的长连接与短连接的区别" class="headerlink" title="HTTP的长连接与短连接的区别"></a>HTTP的长连接与短连接的区别</h4><p><strong>短链接</strong>：在 HTTP/1.0 中默认使用短链接，也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个 HTML 或其他类型的 Web 资源，如CSS 文件等。当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话.</p>
<p><strong>长链接</strong>：从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<h4 id="Cookie，Session，Token的区别是什么？"><a href="#Cookie，Session，Token的区别是什么？" class="headerlink" title="Cookie，Session，Token的区别是什么？"></a><strong>Cookie，Session，Token的区别是什么？</strong></h4><p>Cookie、Session和Token是用于在Web应用程序中管理用户状态和身份验证的技术。因为在Web应用中，HTTP的通信是无状态的，每个请求都是完全独立的，所以服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。</p>
<p>Cookie，是由服务器发送给用户浏览器的小型文本文件，存储在<strong>客户端</strong>的浏览器中。它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。服务器可以读取Cookie并使其中的信息来进行识别和个性化处理。</p>
<p>Session是在<strong>服务器</strong>端创建和管理的一种会话机制。当户首次访问网站时，服务器会为该用户创建一个唯一的Session ID，通常通过Cookie在客户端进行存储。会话标识符在后续的请求中用于标识具体是哪个用户。</p>
<p>Token也是一种用于用户身份鉴权的手段。他其实是一种代表用户身份验证和授权的令牌。 在Web应用程序中,常用的身份验证方案是基于令牌的身份验证(Token-based Authentication)。当户成功登陆时，服务器会生成一个Token并将其返回给客户端。客户端在后续的请求中将Token包含在请求头或请求参数中发送给服务器。服务器接收到Token后，会进行验证和解析，以确定用户的身份和权限。</p>
<h4 id="路由器与交换机的区别是什么？"><a href="#路由器与交换机的区别是什么？" class="headerlink" title="路由器与交换机的区别是什么？"></a>路由器与交换机的区别是什么？</h4><p>在OSI七层模型中，交换机主要工作在数据链路层(第二层)，路由器工作在网络层(第三层)。交换机转发所依据的对象是物理地址，也就是MAC地址，而路由器转发所依据的对象时网络地址，也就是IP地址。交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入互联网。</p>
<h4 id="什么是TCP三次握手、四次挥手？"><a href="#什么是TCP三次握手、四次挥手？" class="headerlink" title="什么是TCP三次握手、四次挥手？"></a>什么是TCP三次握手、四次挥手？</h4><p><img src="/2024/05/20/mian-shi-zheng-li/1717058455873-1.png"></p>
<ol>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ol>
<p><img src="/2024/05/20/mian-shi-zheng-li/1717058469846-4.png"></p>
<p>对于四次挥手，因为TCP是<strong>全双工通信</strong>，在主动关闭方发送FIN后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的FIN与对客户端的ACK包合并发送，只能先确认ACK，然后服务器待无发送数据时再发送FIN包，所以四次挥手时必须是四次数据包的交互。</p>
<ol>
<li>你(客户端)和朋友(服务器) 通话结束后，告诉他你想挂电话了。这就像是发送一个FIN (结束)信号，表示你想结束这次连接。(client向server发送fin。 client置为FIN_WAIT_1)</li>
<li>朋友听到你想挂电话了，他回应说”知道了，但我还有点事情要处理”，即使他知道对话即将结束。这就相当于服务器发送ACK (确认)信号，确认收到了你想结束连接的请求，可能还需要一些时间来处理剩余的数据。(server向client发送ack。 server置为CLOSE_WAIT, client置为FIN_WAIT_2)</li>
<li>一段时间后，你的朋友处理完了他的事情，这时他打电话告诉你他也准备好挂电话了。这是服务器端发送第二个FIN信号，表明他现在也准备好结束这次连接。(等server传输数据完毕后，向client发送fin。 server置为LAST_ACK)</li>
<li>最后，你回复说你收到了他的消息，现在可以挂电话了。这就是发送最后一个ACK号，确认收到服务器端的结束请求。(client向server发送ack。 client置 为TIME_WAIT。之后等待2MSL，client关闭。server接收到后置为CLOSED)</li>
</ol>
<h4 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h4><ul>
<li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>三次握手和四次挥手</strong></li>
<li><strong>流量控制</strong>：TCP 连接的每方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。滑动窗口协议</li>
<li>拥堵控制：TCP使用拥塞控制算法来确保网络中没有过多的数据导致拥塞。</li>
<li>ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。 在收到确认后再发下一个分组。</li>
<li>超时重传：当TCP发出一个后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h4 id="HTTPS和HTTP的区别是什么？"><a href="#HTTPS和HTTP的区别是什么？" class="headerlink" title="HTTPS和HTTP的区别是什么？"></a>HTTPS和HTTP的区别是什么？</h4><ol>
<li>安全性：HTTP是明文传输的，不加密。HTTPS是加密传输。</li>
<li>URL：HTTP以http://开头。HTTPS以https://开头</li>
<li>证书：HTTP不需要使用数字证书。HTTPS需要使用数字证书。</li>
<li>默认端口：HTTP默认端口80。HTTPS默认端口为443.</li>
</ol>
<h4 id="简单介绍一下DNS？"><a href="#简单介绍一下DNS？" class="headerlink" title="简单介绍一下DNS？"></a>简单介绍一下DNS？</h4><p>DNS，是Domain Name System的缩写，翻译成域名系统。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS最主要的作用就是将域名翻译成ip地址。</p>
<h4 id="ping的原理是什么？"><a href="#ping的原理是什么？" class="headerlink" title="ping的原理是什么？"></a>ping的原理是什么？</h4><p>ping命令利用了ICMP两种类型的控制消息：**”echo request” (回显请求)<strong>、</strong>“echo reply””(回显应答)** 。在主机A上执行ping命令，目标主机是B。在A主机上就会发送”echo request” (回显请求) 控制消息，主机B正确接收后即发回”echo reply”(回显应答) 控制消息，通过对方向复的数据包来确定两台网络机器是否连接相通，时延是多少。</p>
<p>ping命令本身处于应用层，相当于一个应用程序。 它使用的ICMP协议是一个网络层协议，也就是说，ping是一个应用层直接使用网络层协议的例子。</p>
<h4 id="从输入URL到页面展示发生了什么？"><a href="#从输入URL到页面展示发生了什么？" class="headerlink" title="从输入URL到页面展示发生了什么？"></a>从输入URL到页面展示发生了什么？</h4><ol>
<li>在浏览器中输入指定的URL</li>
<li>浏览器通过DNS协议，获取域名的IP地址</li>
<li>浏览器依据IP地址和端口号，向目标服务器发起一个TCP请求</li>
<li>在TCP连接上，向服务器发送一个HTTP请求报文，获取网页内容。期间三次握手</li>
<li>服务器接收到HTTP请求报文后，处理请求，返回HTTP响应报文给浏览器</li>
<li>接收到HTTP响应报文以后，解析响应体中HTML代码，渲染网页结构和样式，依据HTML中其他资源的URL，再次发送HTTP请求，获取这些资源。</li>
<li>浏览器不再和服务器通信时，主动关闭TCP连接，或等待服务器的关闭请求。</li>
</ol>
<h4 id="UDP和TCP的区别？"><a href="#UDP和TCP的区别？" class="headerlink" title="UDP和TCP的区别？"></a>UDP和TCP的区别？</h4><p><img src="/2024/05/20/mian-shi-zheng-li/1717058511036-7.png"></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="计算机打开电源操作系统做了什么"><a href="#计算机打开电源操作系统做了什么" class="headerlink" title="计算机打开电源操作系统做了什么?"></a>计算机打开电源操作系统做了什么?</h4><ol>
<li>加载BIOS：计算机主板的BIOS开始工作，开始检测计算机的硬件是否正常</li>
<li>加载引导程序：自检完成后，BIOS会从启动设备(如硬盘、光盘)中加载操作系统的引导程序</li>
<li>初始化内核：引导程序会进一步加载操作内核和文件系统等组件</li>
<li>加载设备驱动程序：使计算机中的各种硬件设备，如硬盘、显卡、网卡等正常工作</li>
<li>启动服务系统：如网络服务、远程登陆，防火墙服务等</li>
</ol>
<h4 id="操作系统的IO模型有哪些？"><a href="#操作系统的IO模型有哪些？" class="headerlink" title="操作系统的IO模型有哪些？"></a>操作系统的IO模型有哪些？</h4><p>为了保护操作系统的安全，通过缓存加快系统读写，会将内存分为用户空间和内核空间两个部分。如果用户想要操作内核空间的数据，则需要把数据从内核空间拷贝到用户空间(数据会放到内核空间的page cache中，这种也叫缓存IO)。</p>
<ul>
<li>同步堵塞IO模型：从系统调用recv到将数据从内核复制到用户空间并返回，在这段时间内进程始终堵塞。</li>
<li>同步非堵塞IO模型：在这里recv不管有没有获得到数据都返回，如果没有数据的话就过段时间再调用recv看看，如此循环。</li>
<li>IO复用模型：在IO复用模型中，调用recv之前会先调用select或poll，这两个系统调用都可以在内核准备好数据(网络数据已经到达内核了)时告知用户进程，它准备好了，这时候再调用recv时是一定有数据的。因此在这一模型中，进程阻塞于select或poll，而没有阻塞在recv上。</li>
<li>信号驱动IO模型：会调用sigaction注册信号函数，在内核数据准备好的时候系统就中断当前程序，执行信号函数(调用recv)</li>
<li>异步IO模型：调用aio_read令内核把数据准备好，并且复制到用户进程空间后执行事先指定好的函数。</li>
</ul>
<h4 id="如何理解select、poll、epoll？"><a href="#如何理解select、poll、epoll？" class="headerlink" title="如何理解select、poll、epoll？"></a>如何理解select、poll、epoll？</h4><ul>
<li>select是最原始的I/O多路复用技术，它的缺点是最多只能监听1024个文件描述符。</li>
<li>poll在select的基础上增加了支持监听更多的文件描述符的能力，但是复杂度随着监听的文件描述符数量的增加而增加。</li>
<li>epoll在poll的基础上进一步优化了复杂度，可以持更多的文件描述符，并且具有更高的效率。</li>
</ul>
<h4 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h4><p><img src="/2024/05/20/mian-shi-zheng-li/1717058725623-10.png"></p>
<p>零拷贝，作用就是通过各种方式，在特殊情况下，减少数据拷贝的次数/减少CPU参与数据拷贝的次数。</p>
<h4 id="负载（Load）和CPU利用率之间有什么区别？"><a href="#负载（Load）和CPU利用率之间有什么区别？" class="headerlink" title="负载（Load）和CPU利用率之间有什么区别？"></a>负载（Load）和CPU利用率之间有什么区别？</h4><p>CPU利用率表示CPU正在执行指令的时间比例，即CPU忙碌的程度。</p>
<p>负载(Load)通常指的是一段时间内系统等待处理的工作量。</p>
<h4 id="进程间通信方式有哪些？-1"><a href="#进程间通信方式有哪些？-1" class="headerlink" title="进程间通信方式有哪些？"></a>进程间通信方式有哪些？</h4><ul>
<li>管道：半双工的通信方式，允许一个进程写入数据到管道，同时另一个进程从管道中读取数据</li>
<li>消息队列：通过消息缓冲区来进行通信的机制。</li>
<li>共享内存：多个进程可以将同一块内存映射到它们的地址内存中，实现共享内存。</li>
<li>信号量Semaphores：是一种用于进程同步和互斥的通信方式。通过信号量，进程可以对资源加锁和解锁。</li>
<li>套接字Socket：进程可以在不同主机或同一主机上的不同进程之间通信。</li>
<li>文件映射：进程可以通过将文件映射到它们的地址空间来共享数据。</li>
</ul>
<h4 id="什么是用户态、内核态？如何切换的？"><a href="#什么是用户态、内核态？如何切换的？" class="headerlink" title="什么是用户态、内核态？如何切换的？"></a>什么是用户态、内核态？如何切换的？</h4><p>操作系统将应用程序和操作系统内核进行了隔离，确保内核能够独立地控制硬件资源。操作系统内核是运行在特权模式下的，可以访问所有硬件资源和底层系统资源，而应用程序是运行在非特权模式下的，只能访问被授权的资源，不能直接操作硬件资源和底层系统资源。</p>
<p><strong>内核态</strong>是操作系统运行在特权模式下的状态，此时操作系统具有最高的权限，可以访问所有的硬件资源和底层系统资源，如处理器、内存、I/O等。</p>
<p><strong>用户态</strong>是指应用程序运行在非特权模式下的状态，此时应用程序只能访问被授权的资源，不能直接操作硬件资源和底层系统资源。</p>
<h4 id="什么是时间片"><a href="#什么是时间片" class="headerlink" title="什么是时间片"></a>什么是时间片</h4><p>为了看起来像是“同时干多件事”，分时操作系统是把CPU的时间划分成长短基本相同的时间区间，即”时间片”。</p>
<h4 id="什么是操作系统的多级缓存"><a href="#什么是操作系统的多级缓存" class="headerlink" title="什么是操作系统的多级缓存"></a>什么是操作系统的多级缓存</h4><p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>
<p>而随着CPU能力不断提升，一层缓存就无法满足要求了，就逐渐衍生出多级缓存。当CPU要读取一个数据时，首先从一级缓存中查找， 如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p>
<h4 id="GPU和CPU区别？为什么挖矿、大模型都用GPU？"><a href="#GPU和CPU区别？为什么挖矿、大模型都用GPU？" class="headerlink" title="GPU和CPU区别？为什么挖矿、大模型都用GPU？"></a>GPU和CPU区别？为什么挖矿、大模型都用GPU？</h4><p>CPU(中央处理单元)是计算机的大脑，专用于执行各种通用任务，如操作系统管理、数据处理、多任务处理等。它的架构设计旨在适应多种任务，具有较少的核心，每个核心非常强大且灵活。</p>
<p>GPU(图形处理单元)最初是为图形渲染和图像处理而设计的，因此其架构包含大量的小核心，适给并行处理。这些核心可以同时处理多个相似的任务，使其在某些计算任务中表现得比CPU更高效。</p>
<p><strong>CPU核心数少、GPU核心数多; CPU适合做各种复杂任务，GPU适合做重复性的计算任务。</strong></p>
<h4 id="线程的实现方式有哪些？"><a href="#线程的实现方式有哪些？" class="headerlink" title="线程的实现方式有哪些？"></a>线程的实现方式有哪些？</h4><p>主要有三种：1.使用内核线程实现；2.使用用户线程实现；3.使用用户线程加轻量级进程混合实现。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="什么是微服务架构？优势？特点？"><a href="#什么是微服务架构？优势？特点？" class="headerlink" title="什么是微服务架构？优势？特点？"></a>什么是微服务架构？优势？特点？</h4><p>微服务(Microservices) 是一种软件架构风格, 用于构建复杂的应用程序。它将一个大型的应用程序拆分成一组小型、独立的服务单元,每个服务单元都可以独立部署、运行和扩展。每个微服务都专注于执行一个特定的业务功能，并通过轻量级的通信机制(如HTTP、RPC、MQ等)来相互调用。</p>
<p>微服务的目的是有效的拆分应用，实现敏捷开发和部署。并且每个服务都可以独立的提供子服务。并且他们有自己的应用、自己的存储，是独立的，互不影响的。</p>
<p>缺点：数据不一致的问题，维护难度大</p>
<h4 id="如何进行微服务的拆分？"><a href="#如何进行微服务的拆分？" class="headerlink" title="如何进行微服务的拆分？"></a>如何进行微服务的拆分？</h4><ul>
<li>按业务功能进行拆分，具有不同功能的模块单独拆分出来作为一个微服务。</li>
<li>也需要按照组织架构进行拆分。康威定律。</li>
<li>按照应用类型进行拆分。</li>
<li>按照技术架构进行拆分。</li>
</ul>
<h4 id="微服务架构的服务治理有哪些实现方案？"><a href="#微服务架构的服务治理有哪些实现方案？" class="headerlink" title="微服务架构的服务治理有哪些实现方案？"></a>微服务架构的服务治理有哪些实现方案？</h4><ul>
<li><strong>服务注册与发现</strong>是微服务架构中必不可少的一个环节。微服务可以向注册中心注册服务的信息(如地址、端口等)， 其他微服务可以通过服务发现机制动态地获取可以进行调用的服务信息，从而实现服务之间的通信。实现方案：ZooKeeper，Consul，Eureka</li>
<li><strong>负载均衡</strong>是指将请求分配到多个服务实例中，以达到分摊负载的目的，常见的实现方案有：Ribbon，Nginx</li>
<li><strong>熔断机制</strong>，当某个微服务发生故障或不可用时，可以快速断开该服务的调用，防止故障扩散，并提供备用响应或执其他补救措施。这就是熔断机制。常见的实现方案有：Hystrix；Sentinel: Sentinel是阿里开源的一个流量控制和容错框架， 可以实现服务的熔断、降级、限流和系统保护等。 在一段时间戳内，总访问/总断开&lt;阈值</li>
<li><strong>限流机制</strong>，限制服务的访问量，限制每个微服务的请求频率或并发数，防止服务过载和雪崩效应的发生。常见的实现方有:Rate Limiter；Istio；Sentinel。 滑动窗口限流</li>
<li><strong>降级机制</strong>，在资源紧张或故障情况下，可以通过降级机制优先处理重要或核心功能，暂时关闭排关键功能，保证核心功能的正常运行。常见的实现方有：Hystrix；Sentinel。</li>
</ul>
<h4 id="微服务中的CI-CD了解吗？"><a href="#微服务中的CI-CD了解吗？" class="headerlink" title="微服务中的CI/CD了解吗？"></a>微服务中的CI/CD了解吗？</h4><p>CI是持续集成，是一种软件开发实践，要求经常集成其变更，方式是变更合并到主干。</p>
<p>CD是持续交付和持续部署，交付目的是在早期、快速、可靠地发布高质量软件，满足业务要求。部署是定期将新功能部署到生产环境的过程。</p>
<h4 id="限流、降级、熔断有什么区别？"><a href="#限流、降级、熔断有什么区别？" class="headerlink" title="限流、降级、熔断有什么区别？"></a>限流、降级、熔断有什么区别？</h4><p><img src="/2024/05/20/mian-shi-zheng-li/1716888560856-1.png" alt="img"></p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h4><p>默认端口为 8080，可以通过在 tomcat 安装包 conf 目录下，service.xml 中的 Connector 元素的 port 属性来修改端口。</p>
<h4 id="tomacat有哪几种Connector运行模式"><a href="#tomacat有哪几种Connector运行模式" class="headerlink" title="tomacat有哪几种Connector运行模式"></a>tomacat有哪几种Connector运行模式</h4><p>BIO：一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。</p>
<p>NIO：利用 Java 的异步 IO 处理，可以通过少量的线程处理大量的请求。</p>
<p>APR：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。</p>
<h4 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h4><ol>
<li>当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件，然后对 xml文件进行解析，并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）</li>
<li>在 servlet 注册时加上 1 如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ol>
<h4 id="tomcat结构目录有哪些？"><a href="#tomcat结构目录有哪些？" class="headerlink" title="tomcat结构目录有哪些？"></a>tomcat结构目录有哪些？</h4><ul>
<li><strong>bin</strong>：启动，关闭和其他脚本。</li>
<li><strong>conf</strong>：tomcat的配置文件和相关DTD，重要的文件有server.xml，是容器的主要配置文件。</li>
<li><strong>logs</strong>：日志文件默认位于此处。</li>
<li><strong>webapps</strong>：项目 webapp 所在的位置。其实这里面这几个都是一个项目。</li>
<li><strong>lib</strong>：tomcat存放共用的类库。如JSP编译器等</li>
<li><strong>work</strong>：存放 tomcat 运行时编译后的文件，比如 JSP 编译后的文件</li>
<li><strong>temp</strong>：存放运行时产生的临时文件。</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>解释</strong></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>top</strong></td>
<td align="center"><strong>查看内存</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>df -h</strong></td>
<td align="center"><strong>查看磁盘存储情况</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>iotop</strong></td>
<td align="center"><strong>查看磁盘 IO 读写</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>iotop -o</strong></td>
<td align="center"><strong>直接查看比较高的磁盘读写程序</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>netstat -tunlp | grep 端口号</strong></td>
<td align="center"><strong>查看端口占用情况</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>uptime</strong></td>
<td align="center"><strong>查看报告系统运行时长及平均负载</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>ps aux</strong></td>
<td align="center"><strong>查看进程</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>系统基本信息：uname</li>
<li>Linux发行版信息： lsb_release</li>
<li>CPU详细信息：lscpu</li>
<li>内存使用情况：free</li>
<li>系统实时进程状态： top</li>
<li>网络接口信息： ifconfig</li>
<li>网络连接相关信息：netstat</li>
<li>磁盘分区信息：fdisk</li>
<li>系统主机名等信息：hostnamectl</li>
</ol>
<h4 id="如何查看测试项目的日志"><a href="#如何查看测试项目的日志" class="headerlink" title="如何查看测试项目的日志"></a>如何查看测试项目的日志</h4><p>一般测试的项目里面，有个 logs 的目录文件，会存放日志文件，有个 xxx.out 的文件，可以用 tail -f 动态实时查看后端日志。先 cd 到 logs 目录(里面有 xx.out 文件)</p>
<pre class="line-numbers language-Linux" data-language="Linux"><code class="language-Linux">tail -f xx.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><img src="/2024/05/20/mian-shi-zheng-li/1717058845900-13.png"></p>
<p><img src="/2024/05/20/mian-shi-zheng-li/1717058850720-16.png"></p>
<ul>
<li><strong>冒泡排序</strong>：比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li><strong>选择排序</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li><strong>插入排序</strong>：将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。</li>
<li><strong>希尔排序</strong>：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</li>
<li><strong>归并排序</strong>：1.将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。2.将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</li>
<li><strong>快速排序</strong>：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
<li><strong>堆排序</strong>：利用堆这种数据结构所设计的一种排序算法。1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端。2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1。3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</li>
<li><strong>计数排序</strong>：计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。1.找出待排序的数组中最大和最小的元素。2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项。3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）。4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
<li><strong>桶排序</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。需要做到：1.在额外空间充足的情况下，尽量增大桶的数量。2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中。</li>
<li><strong>基数排序</strong>：将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
</ul>
<p>计数排序：每个桶只存储单一键值。桶排序：每个桶存储一定范围的数值。基数排序：依据键值的每位数字来分配桶。</p>
<h3 id="场景设计题"><a href="#场景设计题" class="headerlink" title="场景设计题"></a>场景设计题</h3><h4 id="假设有一个论坛留言，数据量很大，需要用好几个数据库，这个主键怎么设计，必须保证全局唯一和递增。"><a href="#假设有一个论坛留言，数据量很大，需要用好几个数据库，这个主键怎么设计，必须保证全局唯一和递增。" class="headerlink" title="假设有一个论坛留言，数据量很大，需要用好几个数据库，这个主键怎么设计，必须保证全局唯一和递增。"></a>假设有一个论坛留言，数据量很大，需要用好几个数据库，这个主键怎么设计，必须保证全局唯一和递增。</h4><ol>
<li>使用分布式唯一ID生成器（雪花算法）</li>
</ol>
<p><strong>实现方式</strong>：这些算法通常基于时间戳、机器ID和序列号等因素来生成ID，确保全局唯一性。</p>
<ol>
<li>使用数据库自增主键结合分布式缓存</li>
</ol>
<p><strong>实现方式</strong>：每个数据库维护自己的自增主键。在生成新主键时，先查询分布式缓存中的当前全局最大主键。</p>
<p>根据查询到的最大主键和当前数据库的自增主键范围，计算新的主键。将新生成的主键写入分布式缓存，并更新到数据库中。</p>
<ol>
<li>使用UUID作为主键</li>
</ol>
<p><strong>缺点</strong>：不保证递增性，可能对某些查询和排序操作不太友好。</p>
<h4 id="一百亿个文件怎么在100MB内存中排序"><a href="#一百亿个文件怎么在100MB内存中排序" class="headerlink" title="一百亿个文件怎么在100MB内存中排序"></a>一百亿个文件怎么在100MB内存中排序</h4><p>因为单个文件的信息可能远超过这100MB的限制。传统的内存排序算法，如快速排序、归并排序等，在这种场景下不适用，因为无法一次性将所有文件加载到内存中。</p>
<p>一种可能的解决方案是使用外部排序（External Sorting）的方法，这种方法结合了内存和磁盘操作，以处理超出内存大小的数据集。以下是一个简化的步骤说明：</p>
<ol>
<li><strong>分块处理</strong>：将文件分成多个小块，每个小块的大小适合内存处理。这通常意味着每个小块的大小会远小于100MB，以便在内存中有效地进行排序。</li>
<li><strong>内存****排序</strong>：对每个小块使用高效的内存排序算法（如快速排序、堆排序等）进行排序。</li>
<li><strong>写入磁盘</strong>：将排序后的小块写回到磁盘上，保持排序后的顺序。</li>
<li><strong>归并排序</strong>：使用多路归并算法（如k路归并）来合并这些已排序的小块，形成一个完整的排序文件。这通常涉及到读取多个磁盘上的小块，将它们合并到内存中，排序，然后再写回磁盘。</li>
<li><strong>迭代优化</strong>：根据归并排序的结果，可能还需要进行多轮迭代和优化，以进一步提高排序的效率和准确性。</li>
</ol>
<p>如果文件的内容可以进行某种形式的压缩或编码，那么可能可以通过减少文件的大小来进一步优化这个过程。</p>
<h4 id="不用redis分布式锁，-如何防止用户重复点击？"><a href="#不用redis分布式锁，-如何防止用户重复点击？" class="headerlink" title="不用redis分布式锁， 如何防止用户重复点击？"></a>不用redis分布式锁， 如何防止用户重复点击？</h4><ol>
<li>前端做一些按键置灰的动作，让用户点击一次就直接禁止，无法点击。</li>
<li>可以通过token的机制避免重复提交，当用户访问页面的时候，请求后端服务拿到一个token，然后下一次接口点击把token带过来，服务端对token进行验证，验证是否被使用过，没有使用过才进行点击。</li>
<li>滑动窗口限流，用于控制在一定时间内允许执行的操作数量或请求频率。可以限制一分钟或者一秒钟内户只能发起一次请求来防止重复击。</li>
<li>可以使用布隆过滤器，他可以快速判断某个元是否存在于集合中。可以在服务器端使用布隆过滤器记录某个操作是否已经被执行过，从而防止重复执行。</li>
</ol>
<h4 id="如何用Redis实现朋友圈点赞功能？"><a href="#如何用Redis实现朋友圈点赞功能？" class="headerlink" title="如何用Redis实现朋友圈点赞功能？"></a>如何用Redis实现朋友圈点赞功能？</h4><ol>
<li>使用字符串存储每篇朋友圈的ID，作为有集合的KEY。</li>
<li>使用zset存储每篇朋友圈的点赞用户信息，中value为点赞用户的ID, score为点赞时间的时间戳。</li>
<li>点赞操作：将用户的ID添加到zset中，score为当前时间戳。 如果户已经点过赞，则更新其点赞时间戳。</li>
<li>取消点赞操作：将用户的ID从有序集合中删除。</li>
<li>查询点赞信息：使有序集合的ZREVRANGEBYSCORE命令，按照score (即时间戳)逆序返回zset的value，即为点赞用户的ID。</li>
</ol>
<h4 id="说一说多级缓存是如何应用的？"><a href="#说一说多级缓存是如何应用的？" class="headerlink" title="说一说多级缓存是如何应用的？"></a>说一说多级缓存是如何应用的？</h4><p>一个真实的秒杀业务，从前到后，可能涉及5个缓存。</p>
<p><img src="/2024/05/20/mian-shi-zheng-li/1717058942632-19.png"></p>
<ol>
<li>客户端缓存，秒杀页面的倒计时，避免每一秒都向后端发送请求。</li>
<li>CDN缓存，比如一些商铺信息、图片信息，这些前端的静态资源的变化频率并不是很高。</li>
<li>Nginx缓存，经过Nginx做负载均衡，在秒杀场景中，我们需要做一用户的鉴权，比如用户是否登录，是否是黄牛用户，用户的IP是否被封禁。这些信息一般是放在Nginx中的，可以在这里面做一些前置的校验， 把一些非法的请求就直接都给拒绝掉了。</li>
<li>Web App缓存，比如一次秒杀活动的开始和结束时间、比如秒杀的用户的用户等级这些信息，基本都是变化没那么频繁的，就可以放到本地缓存中，可以快速的读取。</li>
<li>分布式缓存，redis。</li>
</ol>
<h4 id="InnoDB为什么不用跳表，Redis为什么不用B-树？"><a href="#InnoDB为什么不用跳表，Redis为什么不用B-树？" class="headerlink" title="InnoDB为什么不用跳表，Redis为什么不用B+树？"></a>InnoDB为什么不用跳表，Redis为什么不用B+树？</h4><p>MySQL是基于磁盘存储的，Redis是基于内存存储的。而B+树是一种磁盘IO友好型的数据结构，跳表则是一种内存友好型的数据结构。</p>
<p>首先，B+树的叶子节点形成有序链表，可以方便地进行范围查询操作。对于磁盘存储来说，顺序读取的效率要高于随机读取，因为它可以分利用磁盘预读和缓存机制，减少磁盘I/O的次数。</p>
<p>其次，由于B+树的节点大小是固定的，因此可以很好地利用磁盘预读特性，一次性读取多个节点到内存中，这样可以减少I0操作次数，提高查询效率。</p>
<p>而跳表就不一样了，跳表的索引节点通过跳跃指针连接，形成多级索引结构。这导致了跳表的索引节点在磁盘上存储时会出现数据分散的情况，即索引节点之间的物理距离可能较远。对于磁盘存储来说，随机访问分散的数据会增加磁头的寻道时间，导致磁盘I/O的性能下降。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">He Xu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xiezi123caicai.github.io/2024/05/20/mian-shi-zheng-li/">https://xiezi123caicai.github.io/2024/05/20/mian-shi-zheng-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">He Xu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/">
                                    <span class="chip bg-color">面试整理知识点</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '2TCbHQINzryxnsmqLH94khJz-gzGzoHsz',
        appKey: 'fiXGY2a9y9yBnSowrOCJgP8A',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '期待与您交流！'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2024/05/20/mian-shi-zheng-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="面试整理">
                        
                        <span class="card-title">面试整理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                    面试
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <span class="chip bg-color">面试整理知识点</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/20/design-pattern/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Design-pattern">
                        
                        <span class="card-title">Design-pattern</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Here's something encrypted, password is required to continue reading.
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-category">
                                    设计模式
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">
                        <span class="chip bg-color">中间件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2916766519"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <span id="year">2024</span>
            <a href="/about" target="_blank">He Xu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/xiezi123caicai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1024626253@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1024626253" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1024626253" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>



    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
